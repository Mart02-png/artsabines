{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar Bo = Object.defineProperty;\nvar Ro = (t, s, e) => s in t ? Bo(t, s, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: e\n}) : t[s] = e;\nvar d = (t, s, e) => (Ro(t, typeof s != \"symbol\" ? s + \"\" : s, e), e);\nconst Nn = \"aria-describedby\",\n  De = \"aria-expanded\",\n  ke = \"aria-hidden\",\n  Ne = \"aria-modal\",\n  Ns = \"aria-pressed\",\n  Qe = \"aria-selected\",\n  Wo = \"DOMContentLoaded\",\n  ws = \"focus\",\n  Es = \"focusin\",\n  On = \"focusout\",\n  Oe = \"keydown\",\n  Fo = \"keyup\",\n  N = \"click\",\n  Mn = \"mousedown\",\n  jo = \"hover\",\n  Me = \"mouseenter\",\n  $s = \"mouseleave\",\n  zo = \"pointerdown\",\n  Vo = \"pointermove\",\n  Ko = \"pointerup\",\n  _e = \"resize\",\n  Be = \"scroll\",\n  Ts = \"touchstart\",\n  Xo = \"dragstart\",\n  as = \"ArrowDown\",\n  rs = \"ArrowUp\",\n  Os = \"ArrowLeft\",\n  Ms = \"ArrowRight\",\n  ys = \"Escape\",\n  Yo = \"transitionDuration\",\n  Uo = \"transitionDelay\",\n  Ze = \"transitionend\",\n  _n = \"transitionProperty\",\n  qo = navigator.userAgentData,\n  Ae = qo,\n  {\n    userAgent: Qo\n  } = navigator,\n  Le = Qo,\n  _s = /iPhone|iPad|iPod|Android/i;\nAe ? Ae.brands.some(t => _s.test(t.brand)) : _s.test(Le);\nconst Bs = /(iPhone|iPod|iPad)/,\n  Zo = Ae ? Ae.brands.some(t => Bs.test(t.brand)) : ( /* istanbul ignore next */\n  Bs.test(Le));\nLe && Le.includes(\"Firefox\");\nconst {\n  head: Re\n} = document;\n[\"webkitPerspective\", \"perspective\"].some(t => t in Re.style);\nconst Go = (t, s, e, n) => {\n    const o = n || !1;\n    t.addEventListener(s, e, o);\n  },\n  Jo = (t, s, e, n) => {\n    const o = n || !1;\n    t.removeEventListener(s, e, o);\n  },\n  ti = (t, s, e, n) => {\n    const o = i => {\n      (i.target === t || i.currentTarget === t) && (e.apply(t, [i]), Jo(t, s, o, n));\n    };\n    Go(t, s, o, n);\n  },\n  ge = () => {};\n(() => {\n  let t = !1;\n  try {\n    const s = Object.defineProperty({}, \"passive\", {\n      get: () => (t = !0, t)\n    });\n    ti(document, Wo, ge, s);\n  } catch {}\n  return t;\n})();\n[\"webkitTransform\", \"transform\"].some(t => t in Re.style);\n[\"webkitAnimation\", \"animation\"].some(t => t in Re.style);\n[\"webkitTransition\", \"transition\"].some(t => t in Re.style);\nconst it = (t, s) => t.getAttribute(s),\n  Ie = (t, s) => t.hasAttribute(s),\n  O = (t, s, e) => t.setAttribute(s, e),\n  kt = (t, s) => t.removeAttribute(s),\n  g = (t, ...s) => {\n    t.classList.add(...s);\n  },\n  b = (t, ...s) => {\n    t.classList.remove(...s);\n  },\n  h = (t, s) => t.classList.contains(s),\n  ve = t => t != null && typeof t == \"object\" || !1,\n  L = t => ve(t) && typeof t.nodeType == \"number\" && [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].some(s => t.nodeType === s) || !1,\n  y = t => L(t) && t.nodeType === 1 || !1,\n  Ft = /* @__PURE__ */new Map(),\n  At = {\n    data: Ft,\n    /**\n     * Sets web components data.\n     *\n     * @param element target element\n     * @param component the component's name or a unique key\n     * @param instance the component instance\n     */\n    set: (t, s, e) => {\n      y(t) && (Ft.has(s) || Ft.set(s, /* @__PURE__ */new Map()), Ft.get(s).set(t, e));\n    },\n    /**\n     * Returns all instances for specified component.\n     *\n     * @param component the component's name or a unique key\n     * @returns all the component instances\n     */\n    getAllFor: t => Ft.get(t) || null,\n    /**\n     * Returns the instance associated with the target.\n     *\n     * @param element target element\n     * @param component the component's name or a unique key\n     * @returns the instance\n     */\n    get: (t, s) => {\n      if (!y(t) || !s) return null;\n      const e = At.getAllFor(s);\n      return t && e && e.get(t) || null;\n    },\n    /**\n     * Removes web components data.\n     *\n     * @param element target element\n     * @param component the component's name or a unique key\n     */\n    remove: (t, s) => {\n      const e = At.getAllFor(s);\n      !e || !y(t) || (e.delete(t), e.size === 0 && Ft.delete(s));\n    }\n  },\n  F = (t, s) => At.get(t, s),\n  be = t => typeof t == \"string\" || !1,\n  Cs = t => ve(t) && t.constructor.name === \"Window\" || !1,\n  Bn = t => L(t) && t.nodeType === 9 || !1,\n  E = t => Cs(t) ? t.document : Bn(t) ? t : L(t) ? t.ownerDocument : window.document,\n  dt = (t, ...s) => Object.assign(t, ...s),\n  $t = t => {\n    if (!t) return;\n    if (be(t)) return E().createElement(t);\n    const {\n        tagName: s\n      } = t,\n      e = $t(s);\n    if (!e) return;\n    const n = {\n      ...t\n    };\n    return delete n.tagName, dt(e, n);\n  },\n  w = (t, s) => t.dispatchEvent(s),\n  V = (t, s) => {\n    const e = getComputedStyle(t),\n      n = s.replace(\"webkit\", \"Webkit\").replace(/([A-Z])/g, \"-$1\").toLowerCase();\n    return e.getPropertyValue(n);\n  },\n  ei = t => {\n    const s = V(t, _n),\n      e = V(t, Uo),\n      n = e.includes(\"ms\") ? ( /* istanbul ignore next */\n      1) : 1e3,\n      o = s && s !== \"none\" ? parseFloat(e) * n : ( /* istanbul ignore next */\n      0);\n    return Number.isNaN(o) ? ( /* istanbul ignore next */\n    0) : o;\n  },\n  Kt = t => {\n    const s = V(t, _n),\n      e = V(t, Yo),\n      n = e.includes(\"ms\") ? ( /* istanbul ignore next */\n      1) : 1e3,\n      o = s && s !== \"none\" ? parseFloat(e) * n : ( /* istanbul ignore next */\n      0);\n    return Number.isNaN(o) ? ( /* istanbul ignore next */\n    0) : o;\n  },\n  x = (t, s) => {\n    let e = 0;\n    const n = new Event(Ze),\n      o = Kt(t),\n      i = ei(t);\n    if (o) {\n      const c = a => {\n        a.target === t && (s.apply(t, [a]), t.removeEventListener(Ze, c), e = 1);\n      };\n      t.addEventListener(Ze, c), setTimeout(() => {\n        e || w(t, n);\n      }, o + i + 17);\n    } else s.apply(t, [n]);\n  },\n  ht = (t, s) => t.focus(s),\n  Rs = t => [\"true\", !0].includes(t) ? !0 : [\"false\", !1].includes(t) ? !1 : [\"null\", \"\", null, void 0].includes(t) ? null : t !== \"\" && !Number.isNaN(+t) ? +t : t,\n  Ce = t => Object.entries(t),\n  Xt = t => t.toLowerCase(),\n  si = (t, s, e, n) => {\n    const o = {\n        ...e\n      },\n      i = {\n        ...t.dataset\n      },\n      c = {\n        ...s\n      },\n      a = {},\n      l = \"title\";\n    return Ce(i).forEach(([r, f]) => {\n      const p = n && typeof r == \"string\" && r.includes(n) ? r.replace(n, \"\").replace(/[A-Z]/g, v => Xt(v)) : r;\n      a[p] = Rs(f);\n    }), Ce(o).forEach(([r, f]) => {\n      o[r] = Rs(f);\n    }), Ce(s).forEach(([r, f]) => {\n      r in o ? c[r] = o[r] : r in a ? c[r] = a[r] : c[r] = r === l ? it(t, l) : f;\n    }), c;\n  },\n  Ws = t => Object.keys(t),\n  $ = (t, s) => {\n    const e = new CustomEvent(t, {\n      cancelable: !0,\n      bubbles: !0\n    });\n    return ve(s) && dt(e, s), e;\n  },\n  st = {\n    passive: !0\n  },\n  Mt = t => t.offsetHeight,\n  I = (t, s) => {\n    Ce(s).forEach(([e, n]) => {\n      if (n && be(e) && e.includes(\"--\")) t.style.setProperty(e, n);else {\n        const o = {};\n        o[e] = n, dt(t.style, o);\n      }\n    });\n  },\n  ls = t => ve(t) && t.constructor.name === \"Map\" || !1,\n  ni = t => typeof t == \"number\" || !1,\n  bt = /* @__PURE__ */new Map(),\n  u = {\n    /**\n     * Sets a new timeout timer for an element, or element -> key association.\n     *\n     * @param element target element\n     * @param callback the callback\n     * @param delay the execution delay\n     * @param key a unique key\n     */\n    set: (t, s, e, n) => {\n      y(t) && (n && n.length ? (bt.has(t) || bt.set(t, /* @__PURE__ */new Map()), bt.get(t).set(n, setTimeout(s, e))) : bt.set(t, setTimeout(s, e)));\n    },\n    /**\n     * Returns the timer associated with the target.\n     *\n     * @param element target element\n     * @param key a unique\n     * @returns the timer\n     */\n    get: (t, s) => {\n      if (!y(t)) return null;\n      const e = bt.get(t);\n      return s && e && ls(e) ? e.get(s) || /* istanbul ignore next */\n      null : ni(e) ? e : null;\n    },\n    /**\n     * Clears the element's timer.\n     *\n     * @param element target element\n     * @param key a unique key\n     */\n    clear: (t, s) => {\n      if (!y(t)) return;\n      const e = bt.get(t);\n      s && s.length && ls(e) ? (clearTimeout(e.get(s)), e.delete(s), e.size === 0 && bt.delete(t)) : (clearTimeout(e), bt.delete(t));\n    }\n  },\n  we = (t, s) => {\n    const {\n      width: e,\n      height: n,\n      top: o,\n      right: i,\n      bottom: c,\n      left: a\n    } = t.getBoundingClientRect();\n    let l = 1,\n      r = 1;\n    if (s && y(t)) {\n      const {\n        offsetWidth: f,\n        offsetHeight: p\n      } = t;\n      l = f > 0 ? Math.round(e) / f : ( /* istanbul ignore next */\n      1), r = p > 0 ? Math.round(n) / p : ( /* istanbul ignore next */\n      1);\n    }\n    return {\n      width: e / l,\n      height: n / r,\n      top: o / r,\n      right: i / l,\n      bottom: c / r,\n      left: a / l,\n      x: a / l,\n      y: o / r\n    };\n  },\n  St = t => E(t).body,\n  ft = t => E(t).documentElement,\n  Rn = t => L(t) && t.constructor.name === \"ShadowRoot\" || !1,\n  oi = t => t.nodeName === \"HTML\" ? t : y(t) && t.assignedSlot ||\n  // step into the shadow DOM of the parent of a slotted node\n  L(t) && t.parentNode ||\n  // DOM Element detected\n  Rn(t) && t.host ||\n  // ShadowRoot detected\n  ft(t);\nlet Fs = 0,\n  js = 0;\nconst jt = /* @__PURE__ */new Map(),\n  Wn = (t, s) => {\n    let e = s ? Fs : js;\n    if (s) {\n      const n = Wn(t),\n        o = jt.get(n) || /* @__PURE__ */new Map();\n      jt.has(n) || jt.set(n, o), ls(o) && !o.has(s) ? (o.set(s, e), Fs += 1) : e = o.get(s);\n    } else {\n      const n = t.id || t;\n      jt.has(n) ? e = jt.get(n) : (jt.set(n, e), js += 1);\n    }\n    return e;\n  },\n  qt = t => {\n    var s;\n    return t ? Bn(t) ? t.defaultView : L(t) ? (s = t == null ? void 0 : t.ownerDocument) == null ? void 0 : s.defaultView : t : window;\n  },\n  ii = t => Array.isArray(t) || !1,\n  Fn = t => {\n    if (!L(t)) return !1;\n    const {\n        top: s,\n        bottom: e\n      } = we(t),\n      {\n        clientHeight: n\n      } = ft(t);\n    return s <= n && e >= 0;\n  },\n  ci = t => typeof t == \"function\" || !1,\n  ai = t => ve(t) && t.constructor.name === \"NodeList\" || !1,\n  Ct = t => ft(t).dir === \"rtl\",\n  ri = t => L(t) && [\"TABLE\", \"TD\", \"TH\"].includes(t.nodeName) || !1,\n  M = (t, s) => t ? t.closest(s) ||\n  // break out of `ShadowRoot`\n  M(t.getRootNode().host, s) : null,\n  P = (t, s) => y(t) ? t : (L(s) ? s : E()).querySelector(t),\n  Ss = (t, s) => (L(s) ? s : E()).getElementsByTagName(t),\n  tt = (t, s) => (L(s) ? s : E()).querySelectorAll(t),\n  rt = (t, s) => (s && L(s) ? s : E()).getElementsByClassName(t),\n  jn = (t, s) => t.matches(s),\n  Vt = {},\n  zn = t => {\n    const {\n      type: s,\n      currentTarget: e\n    } = t;\n    [...Vt[s]].forEach(([n, o]) => {\n      e === n && [...o].forEach(([i, c]) => {\n        i.apply(n, [t]), typeof c == \"object\" && c.once && B(n, s, i, c);\n      });\n    });\n  },\n  _ = (t, s, e, n) => {\n    Vt[s] || (Vt[s] = /* @__PURE__ */new Map());\n    const o = Vt[s];\n    o.has(t) || o.set(t, /* @__PURE__ */new Map());\n    const i = o.get(t),\n      {\n        size: c\n      } = i;\n    i.set(e, n), c || t.addEventListener(s, zn, n);\n  },\n  B = (t, s, e, n) => {\n    const o = Vt[s],\n      i = o && o.get(t),\n      c = i && i.get(e),\n      a = c !== void 0 ? c : n;\n    i && i.has(e) && i.delete(e), o && (!i || !i.size) && o.delete(t), (!o || !o.size) && delete Vt[s], (!i || !i.size) && t.removeEventListener(s, zn, a);\n  },\n  R = \"fade\",\n  m = \"show\",\n  We = \"data-bs-dismiss\",\n  Fe = \"alert\",\n  Vn = \"Alert\",\n  li = \"5.0.11\",\n  di = li;\nclass nt {\n  /**\n   * @param target `HTMLElement` or selector string\n   * @param config component instance options\n   */\n  constructor(s, e) {\n    /** just to have something to extend from */\n    d(this, \"_toggleEventListeners\", () => {});\n    const n = P(s);\n    if (!n) throw be(s) ? Error(`${this.name} Error: \"${s}\" is not a valid selector.`) : Error(`${this.name} Error: your target is not an instance of HTMLElement.`);\n    const o = At.get(n, this.name);\n    o && o._toggleEventListeners(), this.element = n, this.options = this.defaults && Ws(this.defaults).length ? si(n, this.defaults, e || {}, \"bs\") : {}, At.set(n, this.name, this);\n  }\n  /* istanbul ignore next */\n  get version() {\n    return di;\n  }\n  /* istanbul ignore next */\n  get name() {\n    return \"BaseComponent\";\n  }\n  /* istanbul ignore next */\n  get defaults() {\n    return {};\n  }\n  /** Removes component from target element. */\n  dispose() {\n    At.remove(this.element, this.name), Ws(this).forEach(s => {\n      delete this[s];\n    });\n  }\n}\nconst hi = `.${Fe}`,\n  fi = `[${We}=\"${Fe}\"]`,\n  gi = t => F(t, Vn),\n  pi = t => new ne(t),\n  zs = $(`close.bs.${Fe}`),\n  ui = $(`closed.bs.${Fe}`),\n  Vs = t => {\n    const {\n      element: s\n    } = t;\n    w(s, ui), t._toggleEventListeners(), t.dispose(), s.remove();\n  };\nclass ne extends nt {\n  constructor(e) {\n    super(e);\n    d(this, \"dismiss\");\n    // ALERT PUBLIC METHODS\n    // ====================\n    /**\n     * Public method that hides the `.alert` element from the user,\n     * disposes the instance once animation is complete, then\n     * removes the element from the DOM.\n     */\n    d(this, \"close\", () => {\n      const {\n        element: e\n      } = this;\n      e && h(e, m) && (w(e, zs), zs.defaultPrevented || (b(e, m), h(e, R) ? x(e, () => Vs(this)) : Vs(this)));\n    });\n    /**\n     * Toggle on / off the `click` event listener.\n     *\n     * @param add when `true`, event listener is added\n     */\n    d(this, \"_toggleEventListeners\", e => {\n      const n = e ? _ : B,\n        {\n          dismiss: o,\n          close: i\n        } = this;\n      o && n(o, N, i);\n    });\n    this.dismiss = P(fi, this.element), this._toggleEventListeners(!0);\n  }\n  /** Returns component name string. */\n  get name() {\n    return Vn;\n  }\n  /** Remove the component from target element. */\n  dispose() {\n    this._toggleEventListeners(), super.dispose();\n  }\n}\nd(ne, \"selector\", hi), d(ne, \"init\", pi), d(ne, \"getInstance\", gi);\nconst C = \"active\",\n  ct = \"data-bs-toggle\",\n  mi = \"button\",\n  Kn = \"Button\",\n  vi = `[${ct}=\"${mi}\"]`,\n  bi = t => F(t, Kn),\n  wi = t => new oe(t);\nclass oe extends nt {\n  /**\n   * @param target usually a `.btn` element\n   */\n  constructor(e) {\n    super(e);\n    d(this, \"isActive\", !1);\n    // BUTTON PUBLIC METHODS\n    // =====================\n    /**\n     * Toggles the state of the target button.\n     *\n     * @param e usually `click` Event object\n     */\n    d(this, \"toggle\", e => {\n      e && e.preventDefault();\n      const {\n        element: n,\n        isActive: o\n      } = this;\n      !h(n, \"disabled\") && !it(n, \"disabled\") && ((o ? b : g)(n, C), O(n, Ns, o ? \"false\" : \"true\"), this.isActive = h(n, C));\n    });\n    // BUTTON PRIVATE METHOD\n    // =====================\n    /**\n     * Toggles on/off the `click` event listener.\n     *\n     * @param add when `true`, event listener is added\n     */\n    d(this, \"_toggleEventListeners\", e => {\n      (e ? _ : B)(this.element, N, this.toggle);\n    });\n    const {\n      element: n\n    } = this;\n    this.isActive = h(n, C), O(n, Ns, String(!!this.isActive)), this._toggleEventListeners(!0);\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return Kn;\n  }\n  /** Removes the `Button` component from the target element. */\n  dispose() {\n    this._toggleEventListeners(), super.dispose();\n  }\n}\nd(oe, \"selector\", vi), d(oe, \"init\", wi), d(oe, \"getInstance\", bi);\nconst ds = \"data-bs-target\",\n  Lt = \"carousel\",\n  Xn = \"Carousel\",\n  Ks = \"data-bs-parent\",\n  Ei = \"data-bs-container\",\n  X = t => {\n    const s = [ds, Ks, Ei, \"href\"],\n      e = E(t);\n    return s.map(n => {\n      const o = it(t, n);\n      return o ? n === Ks ? M(t, o) : P(o, e) : null;\n    }).filter(n => n)[0];\n  },\n  Ee = `[data-bs-ride=\"${Lt}\"]`,\n  Q = `${Lt}-item`,\n  hs = \"data-bs-slide-to\",\n  Et = \"data-bs-slide\",\n  Tt = \"paused\",\n  Xs = {\n    pause: \"hover\",\n    keyboard: !1,\n    touch: !0,\n    interval: 5e3\n  },\n  gt = t => F(t, Xn),\n  $i = t => new ie(t);\nlet se = 0,\n  Se = 0,\n  Ge = 0;\nconst Je = $(`slide.bs.${Lt}`),\n  fs = $(`slid.bs.${Lt}`),\n  Ys = t => {\n    const {\n      index: s,\n      direction: e,\n      element: n,\n      slides: o,\n      options: i\n    } = t;\n    if (t.isAnimating) {\n      const c = gs(t),\n        a = e === \"left\" ? \"next\" : \"prev\",\n        l = e === \"left\" ? \"start\" : \"end\";\n      g(o[s], C), b(o[s], `${Q}-${a}`), b(o[s], `${Q}-${l}`), b(o[c], C), b(o[c], `${Q}-${l}`), w(n, fs), u.clear(n, Et), t.cycle && !E(n).hidden && i.interval && !t.isPaused && t.cycle();\n    }\n  };\nfunction Ti() {\n  const t = gt(this);\n  t && !t.isPaused && !u.get(this, Tt) && g(this, Tt);\n}\nfunction yi() {\n  const t = gt(this);\n  t && t.isPaused && !u.get(this, Tt) && t.cycle();\n}\nfunction Ci(t) {\n  t.preventDefault();\n  const s = M(this, Ee) || X(this),\n    e = gt(s);\n  if (e && !e.isAnimating) {\n    const n = +(it(this, hs) || /* istanbul ignore next */\n    0);\n    this && !h(this, C) &&\n    // event target is not active\n    !Number.isNaN(n) && e.to(n);\n  }\n}\nfunction Si(t) {\n  t.preventDefault();\n  const s = M(this, Ee) || X(this),\n    e = gt(s);\n  if (e && !e.isAnimating) {\n    const n = it(this, Et);\n    n === \"next\" ? e.next() : n === \"prev\" && e.prev();\n  }\n}\nconst Hi = ({\n  code: t,\n  target: s\n}) => {\n  const e = E(s),\n    [n] = [...tt(Ee, e)].filter(i => Fn(i)),\n    o = gt(n);\n  if (o && !o.isAnimating && !/textarea|input/i.test(s.nodeName)) {\n    const i = Ct(n);\n    t === (i ? Ms : Os) ? o.prev() : t === (i ? Os : Ms) && o.next();\n  }\n};\nfunction Us(t) {\n  const {\n      target: s\n    } = t,\n    e = gt(this);\n  e && e.isTouch && (e.indicator && !e.indicator.contains(s) || !e.controls.includes(s)) && (t.stopImmediatePropagation(), t.stopPropagation(), t.preventDefault());\n}\nfunction xi(t) {\n  const {\n      target: s\n    } = t,\n    e = gt(this);\n  if (e && !e.isAnimating && !e.isTouch) {\n    const {\n      controls: n,\n      indicators: o\n    } = e;\n    [...n, ...o].every(i => i === s || i.contains(s)) || (se = t.pageX, this.contains(s) && (e.isTouch = !0, Yn(e, !0)));\n  }\n}\nconst Pi = t => {\n    Se = t.pageX;\n  },\n  Di = t => {\n    var o;\n    const {\n        target: s\n      } = t,\n      e = E(s),\n      n = [...tt(Ee, e)].map(i => gt(i)).find(i => i.isTouch);\n    if (n) {\n      const {\n          element: i,\n          index: c\n        } = n,\n        a = Ct(i);\n      Ge = t.pageX, n.isTouch = !1, Yn(n), !((o = e.getSelection()) != null && o.toString().length) && i.contains(s) && Math.abs(se - Ge) > 120 && (Se < se ? n.to(c + (a ? -1 : 1)) : Se > se && n.to(c + (a ? 1 : -1))), se = 0, Se = 0, Ge = 0;\n    }\n  },\n  ts = (t, s) => {\n    const {\n      indicators: e\n    } = t;\n    [...e].forEach(n => b(n, C)), t.indicators[s] && g(e[s], C);\n  },\n  Yn = (t, s) => {\n    const {\n        element: e\n      } = t,\n      n = s ? _ : B;\n    n(E(e), Vo, Pi, st), n(E(e), Ko, Di, st);\n  },\n  gs = t => {\n    const {\n        slides: s,\n        element: e\n      } = t,\n      n = P(`.${Q}.${C}`, e);\n    return y(n) ? [...s].indexOf(n) : -1;\n  };\nclass ie extends nt {\n  /**\n   * @param target mostly a `.carousel` element\n   * @param config instance options\n   */\n  constructor(e, n) {\n    super(e, n);\n    /**\n     * Toggles all event listeners for the `Carousel` instance.\n     *\n     * @param add when `TRUE` event listeners are added\n     */\n    d(this, \"_toggleEventListeners\", e => {\n      const {\n          element: n,\n          options: o,\n          slides: i,\n          controls: c,\n          indicators: a\n        } = this,\n        {\n          touch: l,\n          pause: r,\n          interval: f,\n          keyboard: p\n        } = o,\n        v = e ? _ : B;\n      r && f && (v(n, Me, Ti), v(n, $s, yi)), l && i.length > 2 && (v(n, zo, xi, st), v(n, Ts, Us, {\n        passive: !1\n      }), v(n, Xo, Us, {\n        passive: !1\n      })), c.length && c.forEach(D => {\n        D && v(D, N, Si);\n      }), a.length && a.forEach(D => {\n        v(D, N, Ci);\n      }), p && v(E(n), Oe, Hi);\n    });\n    const {\n      element: o\n    } = this;\n    this.direction = Ct(o) ? \"right\" : \"left\", this.isTouch = !1, this.slides = rt(Q, o);\n    const {\n      slides: i\n    } = this;\n    if (i.length >= 2) {\n      const c = gs(this),\n        a = [...i].find(f => jn(f, `.${Q}-next,.${Q}-next`));\n      this.index = c;\n      const l = E(o);\n      this.controls = [...tt(`[${Et}]`, o), ...tt(`[${Et}][${ds}=\"#${o.id}\"]`, l)].filter((f, p, v) => p === v.indexOf(f)), this.indicator = P(`.${Lt}-indicators`, o), this.indicators = [...(this.indicator ? tt(`[${hs}]`, this.indicator) : []), ...tt(`[${hs}][${ds}=\"#${o.id}\"]`, l)].filter((f, p, v) => p === v.indexOf(f));\n      const {\n        options: r\n      } = this;\n      this.options.interval = r.interval === !0 ? Xs.interval : r.interval, a ? this.index = [...i].indexOf(a) : c < 0 && (this.index = 0, g(i[0], C), this.indicators.length && ts(this, 0)), this.indicators.length && ts(this, this.index), this._toggleEventListeners(!0), r.interval && this.cycle();\n    }\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return Xn;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return Xs;\n  }\n  /**\n   * Check if instance is paused.\n   */\n  get isPaused() {\n    return h(this.element, Tt);\n  }\n  /**\n   * Check if instance is animating.\n   */\n  get isAnimating() {\n    return P(`.${Q}-next,.${Q}-prev`, this.element) !== null;\n  }\n  // CAROUSEL PUBLIC METHODS\n  // =======================\n  /** Slide automatically through items. */\n  cycle() {\n    const {\n      element: e,\n      options: n,\n      isPaused: o,\n      index: i\n    } = this;\n    u.clear(e, Lt), o && (u.clear(e, Tt), b(e, Tt)), u.set(e, () => {\n      this.element && !this.isPaused && !this.isTouch && Fn(e) && this.to(i + 1);\n    }, n.interval, Lt);\n  }\n  /** Pause the automatic cycle. */\n  pause() {\n    const {\n      element: e,\n      options: n\n    } = this;\n    !this.isPaused && n.interval && (g(e, Tt), u.set(e, () => {}, 1, Tt));\n  }\n  /** Slide to the next item. */\n  next() {\n    this.isAnimating || this.to(this.index + 1);\n  }\n  /** Slide to the previous item. */\n  prev() {\n    this.isAnimating || this.to(this.index - 1);\n  }\n  /**\n   * Jump to the item with the `idx` index.\n   *\n   * @param idx the index of the item to jump to\n   */\n  to(e) {\n    const {\n        element: n,\n        slides: o,\n        options: i\n      } = this,\n      c = gs(this),\n      a = Ct(n);\n    let l = e;\n    if (!this.isAnimating && c !== l && !u.get(n, Et)) {\n      c < l || c === 0 && l === o.length - 1 ? this.direction = a ? \"right\" : \"left\" : (c > l || c === o.length - 1 && l === 0) && (this.direction = a ? \"left\" : \"right\");\n      const {\n        direction: r\n      } = this;\n      l < 0 ? l = o.length - 1 : l >= o.length && (l = 0);\n      const f = r === \"left\" ? \"next\" : \"prev\",\n        p = r === \"left\" ? \"start\" : \"end\",\n        v = {\n          relatedTarget: o[l],\n          from: c,\n          to: l,\n          direction: r\n        };\n      dt(Je, v), dt(fs, v), w(n, Je), Je.defaultPrevented || (this.index = l, ts(this, l), Kt(o[l]) && h(n, \"slide\") ? u.set(n, () => {\n        g(o[l], `${Q}-${f}`), Mt(o[l]), g(o[l], `${Q}-${p}`), g(o[c], `${Q}-${p}`), x(o[l], () => this.slides && this.slides.length && Ys(this));\n      }, 0, Et) : (g(o[l], C), b(o[c], C), u.set(n, () => {\n        u.clear(n, Et), n && i.interval && !this.isPaused && this.cycle(), w(n, fs);\n      }, 0, Et)));\n    }\n  }\n  /** Remove `Carousel` component from target. */\n  dispose() {\n    const {\n        isAnimating: e\n      } = this,\n      n = {\n        ...this,\n        isAnimating: e\n      };\n    this._toggleEventListeners(), super.dispose(), n.isAnimating && x(n.slides[n.index], () => {\n      Ys(n);\n    });\n  }\n}\nd(ie, \"selector\", Ee), d(ie, \"init\", $i), d(ie, \"getInstance\", gt);\nconst Nt = \"collapsing\",\n  K = \"collapse\",\n  Un = \"Collapse\",\n  Ai = `.${K}`,\n  qn = `[${ct}=\"${K}\"]`,\n  Li = {\n    parent: null\n  },\n  He = t => F(t, Un),\n  Ii = t => new ce(t),\n  qs = $(`show.bs.${K}`),\n  ki = $(`shown.bs.${K}`),\n  Qs = $(`hide.bs.${K}`),\n  Ni = $(`hidden.bs.${K}`),\n  Oi = t => {\n    const {\n      element: s,\n      parent: e,\n      triggers: n\n    } = t;\n    w(s, qs), qs.defaultPrevented || (u.set(s, ge, 17), e && u.set(e, ge, 17), g(s, Nt), b(s, K), I(s, {\n      height: `${s.scrollHeight}px`\n    }), x(s, () => {\n      u.clear(s), e && u.clear(e), n.forEach(o => O(o, De, \"true\")), b(s, Nt), g(s, K), g(s, m), I(s, {\n        height: \"\"\n      }), w(s, ki);\n    }));\n  },\n  Zs = t => {\n    const {\n      element: s,\n      parent: e,\n      triggers: n\n    } = t;\n    w(s, Qs), Qs.defaultPrevented || (u.set(s, ge, 17), e && u.set(e, ge, 17), I(s, {\n      height: `${s.scrollHeight}px`\n    }), b(s, K), b(s, m), g(s, Nt), Mt(s), I(s, {\n      height: \"0px\"\n    }), x(s, () => {\n      u.clear(s), e && u.clear(e), n.forEach(o => O(o, De, \"false\")), b(s, Nt), g(s, K), I(s, {\n        height: \"\"\n      }), w(s, Ni);\n    }));\n  },\n  Mi = t => {\n    const {\n        target: s\n      } = t,\n      e = s && M(s, qn),\n      n = e && X(e),\n      o = n && He(n);\n    o && o.toggle(), e && e.tagName === \"A\" && t.preventDefault();\n  };\nclass ce extends nt {\n  /**\n   * @param target and `Element` that matches the selector\n   * @param config instance options\n   */\n  constructor(e, n) {\n    super(e, n);\n    /**\n     * Toggles on/off the event listener(s) of the `Collapse` instance.\n     *\n     * @param add when `true`, the event listener is added\n     */\n    d(this, \"_toggleEventListeners\", e => {\n      const n = e ? _ : B,\n        {\n          triggers: o\n        } = this;\n      o.length && o.forEach(i => n(i, N, Mi));\n    });\n    const {\n        element: o,\n        options: i\n      } = this,\n      c = E(o);\n    this.triggers = [...tt(qn, c)].filter(a => X(a) === o), this.parent = y(i.parent) ? i.parent : be(i.parent) ? X(o) || P(i.parent, c) : null, this._toggleEventListeners(!0);\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return Un;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return Li;\n  }\n  // COLLAPSE PUBLIC METHODS\n  // =======================\n  /** Hides the collapse. */\n  hide() {\n    const {\n      triggers: e,\n      element: n\n    } = this;\n    u.get(n) || (Zs(this), e.length && e.forEach(o => g(o, `${K}d`)));\n  }\n  /** Shows the collapse. */\n  show() {\n    const {\n      element: e,\n      parent: n,\n      triggers: o\n    } = this;\n    let i, c;\n    n && (i = [...tt(`.${K}.${m}`, n)].find(a => He(a)), c = i && He(i)), (!n || !u.get(n)) && !u.get(e) && (c && i !== e && (Zs(c), c.triggers.forEach(a => {\n      g(a, `${K}d`);\n    })), Oi(this), o.length && o.forEach(a => b(a, `${K}d`)));\n  }\n  /** Toggles the visibility of the collapse. */\n  toggle() {\n    h(this.element, m) ? this.hide() : this.show();\n  }\n  /** Remove the `Collapse` component from the target `Element`. */\n  dispose() {\n    this._toggleEventListeners(), super.dispose();\n  }\n}\nd(ce, \"selector\", Ai), d(ce, \"init\", Ii), d(ce, \"getInstance\", He);\nconst Ot = [\"dropdown\", \"dropup\", \"dropstart\", \"dropend\"],\n  Qn = \"Dropdown\",\n  Zn = \"dropdown-menu\",\n  Gn = t => {\n    const s = M(t, \"A\");\n    return t.tagName === \"A\" &&\n    // anchor href starts with #\n    Ie(t, \"href\") && it(t, \"href\").slice(-1) === \"#\" ||\n    // OR a child of an anchor with href starts with #\n    s && Ie(s, \"href\") && it(s, \"href\").slice(-1) === \"#\";\n  },\n  [et, ps, us, ms] = Ot,\n  Jn = `[${ct}=\"${et}\"]`,\n  Yt = t => F(t, Qn),\n  _i = t => new ae(t),\n  Bi = `${Zn}-end`,\n  Gs = [et, ps],\n  Js = [us, ms],\n  tn = [\"A\", \"BUTTON\"],\n  Ri = {\n    offset: 5,\n    // [number] 5(px)\n    display: \"dynamic\"\n    // [dynamic|static]\n  },\n  es = $(`show.bs.${et}`),\n  en = $(`shown.bs.${et}`),\n  ss = $(`hide.bs.${et}`),\n  sn = $(`hidden.bs.${et}`),\n  to = $(`updated.bs.${et}`),\n  eo = t => {\n    const {\n        element: s,\n        menu: e,\n        parentElement: n,\n        options: o\n      } = t,\n      {\n        offset: i\n      } = o;\n    if (V(e, \"position\") !== \"static\") {\n      const c = Ct(s),\n        a = h(e, Bi);\n      [\"margin\", \"top\", \"bottom\", \"left\", \"right\"].forEach(k => {\n        const ut = {};\n        ut[k] = \"\", I(e, ut);\n      });\n      let r = Ot.find(k => h(n, k)) || /* istanbul ignore next: fallback position */\n      et;\n      const f = {\n          dropdown: [i, 0, 0],\n          dropup: [0, 0, i],\n          dropstart: c ? [-1, 0, 0, i] : [-1, i, 0],\n          dropend: c ? [-1, i, 0] : [-1, 0, 0, i]\n        },\n        p = {\n          dropdown: {\n            top: \"100%\"\n          },\n          dropup: {\n            top: \"auto\",\n            bottom: \"100%\"\n          },\n          dropstart: c ? {\n            left: \"100%\",\n            right: \"auto\"\n          } : {\n            left: \"auto\",\n            right: \"100%\"\n          },\n          dropend: c ? {\n            left: \"auto\",\n            right: \"100%\"\n          } : {\n            left: \"100%\",\n            right: \"auto\"\n          },\n          menuStart: c ? {\n            right: \"0\",\n            left: \"auto\"\n          } : {\n            right: \"auto\",\n            left: \"0\"\n          },\n          menuEnd: c ? {\n            right: \"auto\",\n            left: \"0\"\n          } : {\n            right: \"0\",\n            left: \"auto\"\n          }\n        },\n        {\n          offsetWidth: v,\n          offsetHeight: D\n        } = e,\n        {\n          clientWidth: q,\n          clientHeight: T\n        } = ft(s),\n        {\n          left: j,\n          top: Y,\n          width: Bt,\n          height: at\n        } = we(s),\n        S = j - v - i < 0,\n        J = j + v + Bt + i >= q,\n        ot = Y + D + i >= T,\n        W = Y + D + at + i >= T,\n        z = Y - D - i < 0,\n        H = (!c && a || c && !a) && j + Bt - v < 0,\n        Rt = (c && a || !c && !a) && j + v >= q;\n      if (Js.includes(r) && S && J && (r = et), r === us && (c ? J : S) && (r = ms), r === ms && (c ? S : J) && (r = us), r === ps && z && !W && (r = et), r === et && W && !z && (r = ps), Js.includes(r) && ot && dt(p[r], {\n        top: \"auto\",\n        bottom: 0\n      }), Gs.includes(r) && (H || Rt)) {\n        let k = {\n          left: \"auto\",\n          right: \"auto\"\n        };\n        !H && Rt && !c && (k = {\n          left: \"auto\",\n          right: 0\n        }), H && !Rt && c && (k = {\n          left: 0,\n          right: \"auto\"\n        }), k && dt(p[r], k);\n      }\n      const pt = f[r];\n      I(e, {\n        ...p[r],\n        margin: `${pt.map(k => k && `${k}px`).join(\" \")}`\n      }), Gs.includes(r) && a && a && I(e, p[!c && H || c && Rt ? \"menuStart\" : ( /* istanbul ignore next */\n      \"menuEnd\")]), w(n, to);\n    }\n  },\n  Wi = t => [...t.children].map(s => {\n    if (s && tn.includes(s.tagName)) return s;\n    const {\n      firstElementChild: e\n    } = s;\n    return e && tn.includes(e.tagName) ? e : null;\n  }).filter(s => s),\n  nn = t => {\n    const {\n        element: s,\n        options: e\n      } = t,\n      n = t.open ? _ : B,\n      o = E(s);\n    n(o, N, on), n(o, ws, on), n(o, Oe, ji), n(o, Fo, zi), e.display === \"dynamic\" && [Be, _e].forEach(i => {\n      n(qt(s), i, Vi, st);\n    });\n  },\n  je = t => {\n    const s = [...Ot, \"btn-group\", \"input-group\"].map(e => rt(`${e} ${m}`, E(t))).find(e => e.length);\n    if (s && s.length) return [...s[0].children].find(e => Ot.some(n => n === it(e, ct)));\n  },\n  on = t => {\n    const {\n      target: s,\n      type: e\n    } = t;\n    if (s && y(s)) {\n      const n = je(s),\n        o = n && Yt(n);\n      if (o) {\n        const {\n            parentElement: i,\n            menu: c\n          } = o,\n          a = i && i.contains(s) && (s.tagName === \"form\" || M(s, \"form\") !== null);\n        [N, Mn].includes(e) && Gn(s) && t.preventDefault(), !a && e !== ws && s !== n && s !== c && o.hide();\n      }\n    }\n  },\n  Fi = t => {\n    const {\n        target: s\n      } = t,\n      e = s && M(s, Jn),\n      n = e && Yt(e);\n    n && (t.stopPropagation(), n.toggle(), e && Gn(e) && t.preventDefault());\n  },\n  ji = t => {\n    [as, rs].includes(t.code) && t.preventDefault();\n  };\nfunction zi(t) {\n  const {\n      code: s\n    } = t,\n    e = je(this),\n    n = e && Yt(e),\n    {\n      activeElement: o\n    } = e && E(e);\n  if (n && o) {\n    const {\n        menu: i,\n        open: c\n      } = n,\n      a = Wi(i);\n    if (a && a.length && [as, rs].includes(s)) {\n      let l = a.indexOf(o);\n      o === e ? l = 0 : s === rs ? l = l > 1 ? l - 1 : 0 : s === as && (l = l < a.length - 1 ? l + 1 : l), a[l] && ht(a[l]);\n    }\n    ys === s && c && (n.toggle(), ht(e));\n  }\n}\nfunction Vi() {\n  const t = je(this),\n    s = t && Yt(t);\n  s && s.open && eo(s);\n}\nclass ae extends nt {\n  /**\n   * @param target Element or string selector\n   * @param config the instance options\n   */\n  constructor(e, n) {\n    super(e, n);\n    /**\n     * Toggles on/off the `click` event listener of the `Dropdown`.\n     *\n     * @param add when `true`, it will add the event listener\n     */\n    d(this, \"_toggleEventListeners\", e => {\n      (e ? _ : B)(this.element, N, Fi);\n    });\n    const {\n        parentElement: o\n      } = this.element,\n      [i] = rt(Zn, o);\n    i && (this.parentElement = o, this.menu = i, this._toggleEventListeners(!0));\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return Qn;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return Ri;\n  }\n  // DROPDOWN PUBLIC METHODS\n  // =======================\n  /** Shows/hides the dropdown menu to the user. */\n  toggle() {\n    this.open ? this.hide() : this.show();\n  }\n  /** Shows the dropdown menu to the user. */\n  show() {\n    const {\n      element: e,\n      open: n,\n      menu: o,\n      parentElement: i\n    } = this;\n    if (!n) {\n      const c = je(e),\n        a = c && Yt(c);\n      a && a.hide(), [es, en, to].forEach(l => {\n        l.relatedTarget = e;\n      }), w(i, es), es.defaultPrevented || (g(o, m), g(i, m), O(e, De, \"true\"), eo(this), this.open = !n, ht(e), nn(this), w(i, en));\n    }\n  }\n  /** Hides the dropdown menu from the user. */\n  hide() {\n    const {\n      element: e,\n      open: n,\n      menu: o,\n      parentElement: i\n    } = this;\n    n && ([ss, sn].forEach(c => {\n      c.relatedTarget = e;\n    }), w(i, ss), ss.defaultPrevented || (b(o, m), b(i, m), O(e, De, \"false\"), this.open = !n, nn(this), w(i, sn)));\n  }\n  /** Removes the `Dropdown` component from the target element. */\n  dispose() {\n    this.open && this.hide(), this._toggleEventListeners(), super.dispose();\n  }\n}\nd(ae, \"selector\", Jn), d(ae, \"init\", _i), d(ae, \"getInstance\", Yt);\nconst U = \"modal\",\n  Hs = \"Modal\",\n  xs = \"Offcanvas\",\n  Ki = \"fixed-top\",\n  Xi = \"fixed-bottom\",\n  so = \"sticky-top\",\n  no = \"position-sticky\",\n  oo = t => [...rt(Ki, t), ...rt(Xi, t), ...rt(so, t), ...rt(no, t), ...rt(\"is-fixed\", t)],\n  Yi = t => {\n    const s = St(t);\n    I(s, {\n      paddingRight: \"\",\n      overflow: \"\"\n    });\n    const e = oo(s);\n    e.length && e.forEach(n => {\n      I(n, {\n        paddingRight: \"\",\n        marginRight: \"\"\n      });\n    });\n  },\n  io = t => {\n    const {\n        clientWidth: s\n      } = ft(t),\n      {\n        innerWidth: e\n      } = qt(t);\n    return Math.abs(e - s);\n  },\n  co = (t, s) => {\n    const e = St(t),\n      n = parseInt(V(e, \"paddingRight\"), 10),\n      i = V(e, \"overflow\") === \"hidden\" && n ? 0 : io(t),\n      c = oo(e);\n    s && (I(e, {\n      overflow: \"hidden\",\n      paddingRight: `${n + i}px`\n    }), c.length && c.forEach(a => {\n      const l = V(a, \"paddingRight\");\n      if (a.style.paddingRight = `${parseInt(l, 10) + i}px`, [so, no].some(r => h(a, r))) {\n        const r = V(a, \"marginRight\");\n        a.style.marginRight = `${parseInt(r, 10) - i}px`;\n      }\n    }));\n  },\n  Z = \"offcanvas\",\n  yt = $t({\n    tagName: \"div\",\n    className: \"popup-container\"\n  }),\n  ao = (t, s) => {\n    const e = L(s) && s.nodeName === \"BODY\",\n      n = L(s) && !e ? s : yt,\n      o = e ? s : St(t);\n    L(t) && (n === yt && o.append(yt), n.append(t));\n  },\n  ro = (t, s) => {\n    const e = L(s) && s.nodeName === \"BODY\",\n      n = L(s) && !e ? s : yt;\n    L(t) && (t.remove(), n === yt && !yt.children.length && yt.remove());\n  },\n  Ps = (t, s) => {\n    const e = L(s) && s.nodeName !== \"BODY\" ? s : yt;\n    return L(t) && e.contains(t);\n  },\n  lo = \"backdrop\",\n  cn = `${U}-${lo}`,\n  an = `${Z}-${lo}`,\n  ho = `.${U}.${m}`,\n  Ds = `.${Z}.${m}`,\n  A = $t(\"div\"),\n  _t = t => P(`${ho},${Ds}`, E(t)),\n  As = t => {\n    const s = t ? cn : an;\n    [cn, an].forEach(e => {\n      b(A, e);\n    }), g(A, s);\n  },\n  fo = (t, s, e) => {\n    As(e), ao(A, St(t)), s && g(A, R);\n  },\n  go = () => {\n    h(A, m) || (g(A, m), Mt(A));\n  },\n  ze = () => {\n    b(A, m);\n  },\n  po = t => {\n    _t(t) || (b(A, R), ro(A, St(t)), Yi(t));\n  },\n  uo = t => y(t) && V(t, \"visibility\") !== \"hidden\" && t.offsetParent !== null,\n  Ui = `.${U}`,\n  mo = `[${ct}=\"${U}\"]`,\n  qi = `[${We}=\"${U}\"]`,\n  vo = `${U}-static`,\n  Qi = {\n    backdrop: !0,\n    keyboard: !0\n  },\n  pe = t => F(t, Hs),\n  Zi = t => new re(t),\n  xe = $(`show.bs.${U}`),\n  rn = $(`shown.bs.${U}`),\n  ns = $(`hide.bs.${U}`),\n  ln = $(`hidden.bs.${U}`),\n  bo = t => {\n    const {\n        element: s\n      } = t,\n      e = io(s),\n      {\n        clientHeight: n,\n        scrollHeight: o\n      } = ft(s),\n      {\n        clientHeight: i,\n        scrollHeight: c\n      } = s,\n      a = i !== c;\n    if (!a && e) {\n      const l = Ct(s) ? ( /* istanbul ignore next */\n        \"paddingLeft\") : \"paddingRight\",\n        r = {};\n      r[l] = `${e}px`, I(s, r);\n    }\n    co(s, a || n !== o);\n  },\n  wo = (t, s) => {\n    const e = s ? _ : B,\n      {\n        element: n,\n        update: o\n      } = t;\n    e(n, N, tc), e(qt(n), _e, o, st), e(E(n), Oe, Ji);\n  },\n  dn = t => {\n    const {\n      triggers: s,\n      element: e,\n      relatedTarget: n\n    } = t;\n    po(e), I(e, {\n      paddingRight: \"\",\n      display: \"\"\n    }), wo(t);\n    const o = xe.relatedTarget || s.find(uo);\n    o && ht(o), ln.relatedTarget = n, w(e, ln);\n  },\n  hn = t => {\n    const {\n      element: s,\n      relatedTarget: e\n    } = t;\n    ht(s), wo(t, !0), rn.relatedTarget = e, w(s, rn);\n  },\n  fn = t => {\n    const {\n      element: s,\n      hasFade: e\n    } = t;\n    I(s, {\n      display: \"block\"\n    }), bo(t), _t(s) || I(St(s), {\n      overflow: \"hidden\"\n    }), g(s, m), kt(s, ke), O(s, Ne, \"true\"), e ? x(s, () => hn(t)) : hn(t);\n  },\n  gn = t => {\n    const {\n      element: s,\n      options: e,\n      hasFade: n\n    } = t;\n    e.backdrop && n && h(A, m) && !_t(s) ? (ze(), x(A, () => dn(t))) : dn(t);\n  },\n  Gi = t => {\n    const {\n        target: s\n      } = t,\n      e = s && M(s, mo),\n      n = e && X(e),\n      o = n && pe(n);\n    o && (e && e.tagName === \"A\" && t.preventDefault(), o.relatedTarget = e, o.toggle());\n  },\n  Ji = ({\n    code: t,\n    target: s\n  }) => {\n    const e = P(ho, E(s)),\n      n = e && pe(e);\n    if (n) {\n      const {\n        options: o\n      } = n;\n      o.keyboard && t === ys &&\n      // the keyboard option is enabled and the key is 27\n      h(e, m) && (n.relatedTarget = null, n.hide());\n    }\n  },\n  tc = t => {\n    var n, o;\n    const {\n        currentTarget: s\n      } = t,\n      e = s ? pe(s) : null;\n    if (e && s && !u.get(s)) {\n      const {\n          options: i,\n          isStatic: c,\n          modalDialog: a\n        } = e,\n        {\n          backdrop: l\n        } = i,\n        {\n          target: r\n        } = t,\n        f = (o = (n = E(s)) == null ? void 0 : n.getSelection()) == null ? void 0 : o.toString().length,\n        p = a.contains(r),\n        v = r && M(r, qi);\n      c && !p ? u.set(s, () => {\n        g(s, vo), x(a, () => ec(e));\n      }, 17) : (v || !f && !c && !p && l) && (e.relatedTarget = v || null, e.hide(), t.preventDefault());\n    }\n  },\n  ec = t => {\n    const {\n        element: s,\n        modalDialog: e\n      } = t,\n      n = (Kt(e) || 0) + 17;\n    b(s, vo), u.set(s, () => u.clear(s), n);\n  };\nclass re extends nt {\n  /**\n   * @param target usually the `.modal` element\n   * @param config instance options\n   */\n  constructor(e, n) {\n    super(e, n);\n    /**\n     * Updates the modal layout.\n     */\n    d(this, \"update\", () => {\n      h(this.element, m) && bo(this);\n    });\n    /**\n     * Toggles on/off the `click` event listener of the `Modal` instance.\n     *\n     * @param add when `true`, event listener(s) is/are added\n     */\n    d(this, \"_toggleEventListeners\", e => {\n      const n = e ? _ : B,\n        {\n          triggers: o\n        } = this;\n      o.length && o.forEach(i => n(i, N, Gi));\n    });\n    const {\n        element: o\n      } = this,\n      i = P(`.${U}-dialog`, o);\n    i && (this.modalDialog = i, this.triggers = [...tt(mo, E(o))].filter(c => X(c) === o), this.isStatic = this.options.backdrop === \"static\", this.hasFade = h(o, R), this.relatedTarget = null, this._toggleEventListeners(!0));\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return Hs;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return Qi;\n  }\n  // MODAL PUBLIC METHODS\n  // ====================\n  /** Toggles the visibility of the modal. */\n  toggle() {\n    h(this.element, m) ? this.hide() : this.show();\n  }\n  /** Shows the modal to the user. */\n  show() {\n    const {\n        element: e,\n        options: n,\n        hasFade: o,\n        relatedTarget: i\n      } = this,\n      {\n        backdrop: c\n      } = n;\n    let a = 0;\n    if (!h(e, m) && (xe.relatedTarget = i || void 0, w(e, xe), !xe.defaultPrevented)) {\n      const l = _t(e);\n      if (l && l !== e) {\n        const r = pe(l) || /* istanbul ignore next */\n        F(l, xs);\n        r && r.hide();\n      }\n      c ? (Ps(A) ? As(!0) : fo(e, o, !0), a = Kt(A), go(), setTimeout(() => fn(this), a)) : (fn(this), l && h(A, m) && ze());\n    }\n  }\n  /** Hide the modal from the user. */\n  hide() {\n    const {\n      element: e,\n      hasFade: n,\n      relatedTarget: o\n    } = this;\n    h(e, m) && (ns.relatedTarget = o || void 0, w(e, ns), ns.defaultPrevented || (b(e, m), O(e, ke, \"true\"), kt(e, Ne), n ? x(e, () => gn(this)) : gn(this)));\n  }\n  /** Removes the `Modal` component from target element. */\n  dispose() {\n    const e = {\n        ...this\n      },\n      {\n        element: n,\n        modalDialog: o\n      } = e,\n      i = () => super.dispose();\n    this._toggleEventListeners(), this.hide(), h(n, \"fade\") ? x(o, i) : i();\n  }\n}\nd(re, \"selector\", Ui), d(re, \"init\", Zi), d(re, \"getInstance\", pe);\nconst sc = `.${Z}`,\n  Ls = `[${ct}=\"${Z}\"]`,\n  nc = `[${We}=\"${Z}\"]`,\n  Ve = `${Z}-toggling`,\n  oc = {\n    backdrop: !0,\n    // boolean\n    keyboard: !0,\n    // boolean\n    scroll: !1\n    // boolean\n  },\n  ue = t => F(t, xs),\n  ic = t => new le(t),\n  Pe = $(`show.bs.${Z}`),\n  Eo = $(`shown.bs.${Z}`),\n  os = $(`hide.bs.${Z}`),\n  $o = $(`hidden.bs.${Z}`),\n  cc = t => {\n    const {\n        element: s\n      } = t,\n      {\n        clientHeight: e,\n        scrollHeight: n\n      } = ft(s);\n    co(s, e !== n);\n  },\n  To = (t, s) => {\n    const e = s ? _ : B,\n      n = E(t.element);\n    e(n, Oe, dc), e(n, N, lc);\n  },\n  pn = t => {\n    const {\n      element: s,\n      options: e\n    } = t;\n    e.scroll || (cc(t), I(St(s), {\n      overflow: \"hidden\"\n    })), g(s, Ve), g(s, m), I(s, {\n      visibility: \"visible\"\n    }), x(s, () => hc(t));\n  },\n  ac = t => {\n    const {\n        element: s,\n        options: e\n      } = t,\n      n = _t(s);\n    s.blur(), !n && e.backdrop && h(A, m) && ze(), x(s, () => fc(t));\n  },\n  rc = t => {\n    const s = M(t.target, Ls),\n      e = s && X(s),\n      n = e && ue(e);\n    n && (n.relatedTarget = s, n.toggle(), s && s.tagName === \"A\" && t.preventDefault());\n  },\n  lc = t => {\n    const {\n        target: s\n      } = t,\n      e = P(Ds, E(s)),\n      n = P(nc, e),\n      o = e && ue(e);\n    if (o) {\n      const {\n          options: i,\n          triggers: c\n        } = o,\n        {\n          backdrop: a\n        } = i,\n        l = M(s, Ls),\n        r = E(e).getSelection();\n      (!A.contains(s) || a !== \"static\") && (!(r && r.toString().length) && (!e.contains(s) && a && ( /* istanbul ignore next */\n      !l || c.includes(s)) || n && n.contains(s)) && (o.relatedTarget = n && n.contains(s) ? n : null, o.hide()), l && l.tagName === \"A\" && t.preventDefault());\n    }\n  },\n  dc = ({\n    code: t,\n    target: s\n  }) => {\n    const e = P(Ds, E(s)),\n      n = e && ue(e);\n    n && n.options.keyboard && t === ys && (n.relatedTarget = null, n.hide());\n  },\n  hc = t => {\n    const {\n      element: s\n    } = t;\n    b(s, Ve), kt(s, ke), O(s, Ne, \"true\"), O(s, \"role\", \"dialog\"), w(s, Eo), To(t, !0), ht(s);\n  },\n  fc = t => {\n    const {\n      element: s,\n      triggers: e\n    } = t;\n    O(s, ke, \"true\"), kt(s, Ne), kt(s, \"role\"), I(s, {\n      visibility: \"\"\n    });\n    const n = Pe.relatedTarget || e.find(uo);\n    n && ht(n), po(s), w(s, $o), b(s, Ve), _t(s) || To(t);\n  };\nclass le extends nt {\n  /**\n   * @param target usually an `.offcanvas` element\n   * @param config instance options\n   */\n  constructor(e, n) {\n    super(e, n);\n    /**\n     * Toggles on/off the `click` event listeners.\n     *\n     * @param self the `Offcanvas` instance\n     * @param add when *true*, listeners are added\n     */\n    d(this, \"_toggleEventListeners\", e => {\n      const n = e ? _ : B;\n      this.triggers.forEach(o => n(o, N, rc));\n    });\n    const {\n      element: o\n    } = this;\n    this.triggers = [...tt(Ls, E(o))].filter(i => X(i) === o), this.relatedTarget = null, this._toggleEventListeners(!0);\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return xs;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return oc;\n  }\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    h(this.element, m) ? this.hide() : this.show();\n  }\n  /** Shows the offcanvas to the user. */\n  show() {\n    const {\n      element: e,\n      options: n,\n      relatedTarget: o\n    } = this;\n    let i = 0;\n    if (!h(e, m) && (Pe.relatedTarget = o || void 0, Eo.relatedTarget = o || void 0, w(e, Pe), !Pe.defaultPrevented)) {\n      const c = _t(e);\n      if (c && c !== e) {\n        const a = ue(c) || /* istanbul ignore next */\n        F(c, Hs);\n        a && a.hide();\n      }\n      n.backdrop ? (Ps(A) ? As() : fo(e, !0), i = Kt(A), go(), setTimeout(() => pn(this), i)) : (pn(this), c && h(A, m) && ze());\n    }\n  }\n  /** Hides the offcanvas from the user. */\n  hide() {\n    const {\n      element: e,\n      relatedTarget: n\n    } = this;\n    h(e, m) && (os.relatedTarget = n || void 0, $o.relatedTarget = n || void 0, w(e, os), os.defaultPrevented || (g(e, Ve), b(e, m), ac(this)));\n  }\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const e = {\n        ...this\n      },\n      {\n        element: n,\n        options: o\n      } = e,\n      i = o.backdrop ? Kt(A) : ( /* istanbul ignore next */\n      0),\n      c = () => setTimeout(() => super.dispose(), i + 17);\n    this._toggleEventListeners(), this.hide(), h(n, m) ? x(n, c) : c();\n  }\n}\nd(le, \"selector\", sc), d(le, \"init\", ic), d(le, \"getInstance\", ue);\nconst It = \"popover\",\n  Ke = \"Popover\",\n  lt = \"tooltip\",\n  yo = t => {\n    const s = t === lt,\n      e = s ? `${t}-inner` : `${t}-body`,\n      n = s ? \"\" : `<h3 class=\"${t}-header\"></h3>`,\n      o = `<div class=\"${t}-arrow\"></div>`,\n      i = `<div class=\"${e}\"></div>`;\n    return `<div class=\"${t}\" role=\"${lt}\">${n + o + i}</div>`;\n  },\n  Co = {\n    top: \"top\",\n    bottom: \"bottom\",\n    left: \"start\",\n    right: \"end\"\n  },\n  vs = t => {\n    const s = /\\b(top|bottom|start|end)+/,\n      {\n        element: e,\n        tooltip: n,\n        container: o,\n        options: i,\n        arrow: c\n      } = t;\n    if (n) {\n      const a = {\n          ...Co\n        },\n        l = Ct(e);\n      I(n, {\n        // top: '0px', left: '0px', right: '', bottom: '',\n        top: \"\",\n        left: \"\",\n        right: \"\",\n        bottom: \"\"\n      });\n      const r = t.name === Ke,\n        {\n          offsetWidth: f,\n          offsetHeight: p\n        } = n,\n        {\n          clientWidth: v,\n          clientHeight: D,\n          offsetWidth: q\n        } = ft(e);\n      let {\n        placement: T\n      } = i;\n      const {\n          clientWidth: j,\n          offsetWidth: Y\n        } = o,\n        at = V(o, \"position\") === \"fixed\",\n        S = Math.abs(at ? j - Y : v - q),\n        J = l && at ? ( /* istanbul ignore next */\n        S) : 0,\n        ot = v - (l ? 0 : S) - 1,\n        {\n          width: W,\n          height: z,\n          left: H,\n          right: Rt,\n          top: pt\n        } = we(e, !0),\n        {\n          x: k,\n          y: ut\n        } = {\n          x: H,\n          y: pt\n        };\n      I(c, {\n        top: \"\",\n        left: \"\",\n        right: \"\",\n        bottom: \"\"\n      });\n      let Ht = 0,\n        Qt = \"\",\n        mt = 0,\n        Xe = \"\",\n        Wt = \"\",\n        Te = \"\",\n        Ye = \"\";\n      const xt = c.offsetWidth || 0,\n        vt = c.offsetHeight || 0,\n        Ue = xt / 2;\n      let Zt = pt - p - vt < 0,\n        Gt = pt + p + z + vt >= D,\n        Jt = H - f - xt < J,\n        te = H + f + W + xt >= ot;\n      const ye = [\"left\", \"right\"],\n        qe = [\"top\", \"bottom\"];\n      Zt = ye.includes(T) ? pt + z / 2 - p / 2 - vt < 0 : Zt, Gt = ye.includes(T) ? pt + p / 2 + z / 2 + vt >= D : Gt, Jt = qe.includes(T) ? H + W / 2 - f / 2 < J : Jt, te = qe.includes(T) ? H + f / 2 + W / 2 >= ot : te, T = ye.includes(T) && Jt && te ? \"top\" : T, T = T === \"top\" && Zt ? \"bottom\" : T, T = T === \"bottom\" && Gt ? \"top\" : T, T = T === \"left\" && Jt ? \"right\" : T, T = T === \"right\" && te ? ( /* istanbul ignore next */\n      \"left\") : T, n.className.includes(T) || (n.className = n.className.replace(s, a[T])), ye.includes(T) ? (T === \"left\" ? mt = k - f - (r ? xt : 0) : mt = k + W + (r ? xt : 0), Zt && Gt ? (Ht = 0, Qt = 0, Wt = pt + z / 2 - vt / 2) : Zt ? (Ht = ut, Qt = \"\", Wt = z / 2 - xt) : Gt ? (Ht = ut - p + z, Qt = \"\", Wt = p - z / 2 - xt) : (Ht = ut - p / 2 + z / 2, Wt = p / 2 - vt / 2)) : qe.includes(T) && (T === \"top\" ? Ht = ut - p - (r ? vt : 0) : Ht = ut + z + (r ? vt : 0), Jt ? (mt = 0, Te = k + W / 2 - Ue) : te ? (mt = \"auto\", Xe = 0, Ye = W / 2 + ot - Rt - Ue) : (mt = k - f / 2 + W / 2, Te = f / 2 - Ue)), I(n, {\n        top: `${Ht}px`,\n        bottom: Qt === \"\" ? \"\" : `${Qt}px`,\n        left: mt === \"auto\" ? mt : `${mt}px`,\n        right: Xe !== \"\" ? `${Xe}px` : \"\"\n      }), y(c) && (Wt !== \"\" && (c.style.top = `${Wt}px`), Te !== \"\" ? c.style.left = `${Te}px` : Ye !== \"\" && (c.style.right = `${Ye}px`));\n      const _o = $(`updated.bs.${Xt(t.name)}`);\n      w(e, _o);\n    }\n  },\n  bs = {\n    template: yo(lt),\n    title: \"\",\n    customClass: \"\",\n    trigger: \"hover focus\",\n    placement: \"top\",\n    sanitizeFn: void 0,\n    animation: !0,\n    delay: 200,\n    container: document.body,\n    content: \"\",\n    dismissible: !1,\n    btnClose: \"\"\n  },\n  So = \"data-original-title\",\n  Pt = \"Tooltip\",\n  wt = (t, s, e) => {\n    if (be(s) && s.length) {\n      let n = s.trim();\n      ci(e) && (n = e(n));\n      const i = new DOMParser().parseFromString(n, \"text/html\");\n      t.append(...i.body.childNodes);\n    } else y(s) ? t.append(s) : (ai(s) || ii(s) && s.every(L)) && t.append(...s);\n  },\n  gc = t => {\n    const s = t.name === Pt,\n      {\n        id: e,\n        element: n,\n        options: o\n      } = t,\n      {\n        title: i,\n        placement: c,\n        template: a,\n        animation: l,\n        customClass: r,\n        sanitizeFn: f,\n        dismissible: p,\n        content: v,\n        btnClose: D\n      } = o,\n      q = s ? lt : It,\n      T = {\n        ...Co\n      };\n    let j = [],\n      Y = [];\n    Ct(n) && (T.left = \"end\", T.right = \"start\");\n    const Bt = `bs-${q}-${T[c]}`;\n    let at;\n    if (y(a)) at = a;else {\n      const J = $t(\"div\");\n      wt(J, a, f), at = J.firstChild;\n    }\n    t.tooltip = y(at) ? at.cloneNode(!0) : ( /* istanbul ignore next */\n    void 0);\n    const {\n      tooltip: S\n    } = t;\n    if (S) {\n      O(S, \"id\", e), O(S, \"role\", lt);\n      const J = s ? `${lt}-inner` : `${It}-body`,\n        ot = s ? null : P(`.${It}-header`, S),\n        W = P(`.${J}`, S);\n      t.arrow = P(`.${q}-arrow`, S);\n      const {\n        arrow: z\n      } = t;\n      if (y(i)) j = [i.cloneNode(!0)];else {\n        const H = $t(\"div\");\n        wt(H, i, f), j = [...H.childNodes];\n      }\n      if (y(v)) Y = [v.cloneNode(!0)];else {\n        const H = $t(\"div\");\n        wt(H, v, f), Y = [...H.childNodes];\n      }\n      if (p) if (i) {\n        if (y(D)) j = [...j, D.cloneNode(!0)];else {\n          const H = $t(\"div\");\n          wt(H, D, f), j = [...j, H.firstChild];\n        }\n      } else if (ot && ot.remove(), y(D)) Y = [...Y, D.cloneNode(!0)];else {\n        const H = $t(\"div\");\n        wt(H, D, f), Y = [...Y, H.firstChild];\n      }\n      s ? i && W && wt(W, i, f) : (i && ot && wt(ot, j, f), v && W && wt(W, Y, f), t.btn = P(\".btn-close\", S) || void 0), g(S, \"position-fixed\"), g(z, \"position-absolute\"), h(S, q) || g(S, q), l && !h(S, R) && g(S, R), r && !h(S, r) && g(S, r), h(S, Bt) || g(S, Bt);\n    }\n  },\n  pc = t => {\n    const s = [\"HTML\", \"BODY\"],\n      e = [];\n    let {\n      parentNode: n\n    } = t;\n    for (; n && !s.includes(n.nodeName);) n = oi(n), Rn(n) || ri(n) || e.push(n);\n    return e.find((o, i) => V(o, \"position\") !== \"relative\" && e.slice(i + 1).every(c => V(c, \"position\") === \"static\") ? o : null) || /* istanbul ignore next: optional guard */\n    E(t).body;\n  },\n  uc = `[${ct}=\"${lt}\"],[data-tip=\"${lt}\"]`,\n  Ho = \"title\";\nlet un = t => F(t, Pt);\nconst mc = t => new Dt(t),\n  vc = t => {\n    const {\n      element: s,\n      tooltip: e,\n      container: n,\n      offsetParent: o\n    } = t;\n    kt(s, Nn), ro(e, n === o ? n : o);\n  },\n  ee = t => {\n    const {\n      tooltip: s,\n      container: e,\n      offsetParent: n\n    } = t;\n    return s && Ps(s, e === n ? e : n);\n  },\n  bc = (t, s) => {\n    const {\n      element: e\n    } = t;\n    t._toggleEventListeners(), Ie(e, So) && t.name === Pt && Po(t), s && s();\n  },\n  xo = (t, s) => {\n    const e = s ? _ : B,\n      {\n        element: n\n      } = t;\n    e(E(n), Ts, t.handleTouch, st), [Be, _e].forEach(o => {\n      e(qt(n), o, t.update, st);\n    });\n  },\n  mn = t => {\n    const {\n        element: s\n      } = t,\n      e = $(`shown.bs.${Xt(t.name)}`);\n    xo(t, !0), w(s, e), u.clear(s, \"in\");\n  },\n  vn = t => {\n    const {\n        element: s\n      } = t,\n      e = $(`hidden.bs.${Xt(t.name)}`);\n    xo(t), vc(t), w(s, e), u.clear(s, \"out\");\n  },\n  bn = (t, s) => {\n    const e = s ? _ : B,\n      {\n        element: n,\n        container: o,\n        offsetParent: i\n      } = t,\n      {\n        offsetHeight: c,\n        scrollHeight: a\n      } = o,\n      l = M(n, `.${U}`),\n      r = M(n, `.${Z}`),\n      f = qt(n),\n      v = o === i && c !== a ? o : f;\n    e(v, _e, t.update, st), e(v, Be, t.update, st), l && e(l, `hide.bs.${U}`, t.handleHide), r && e(r, `hide.bs.${Z}`, t.handleHide);\n  },\n  Po = (t, s) => {\n    const e = [So, Ho],\n      {\n        element: n\n      } = t;\n    O(n, e[s ? 0 : 1], s || it(n, e[0]) || /* istanbul ignore next */\n    \"\"), kt(n, e[s ? 1 : 0]);\n  };\nclass Dt extends nt {\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(e, n) {\n    super(e, n);\n    // TOOLTIP PUBLIC METHODS\n    // ======================\n    /** Handles the focus event on iOS. */\n    d(this, \"handleFocus\", () => ht(this.element));\n    /** Shows the tooltip. */\n    d(this, \"handleShow\", () => this.show());\n    /** Hides the tooltip. */\n    d(this, \"handleHide\", () => this.hide());\n    /** Updates the tooltip position. */\n    d(this, \"update\", () => {\n      vs(this);\n    });\n    /** Toggles the tooltip visibility. */\n    d(this, \"toggle\", () => {\n      const {\n        tooltip: e\n      } = this;\n      e && !ee(this) ? this.show() : this.hide();\n    });\n    /**\n     * Handles the `touchstart` event listener for `Tooltip`\n     *\n     * @this {Tooltip}\n     * @param {TouchEvent} e the `Event` object\n     */\n    d(this, \"handleTouch\", ({\n      target: e\n    }) => {\n      const {\n        tooltip: n,\n        element: o\n      } = this;\n      n && n.contains(e) || e === o || e && o.contains(e) || this.hide();\n    });\n    /**\n     * Toggles on/off the `Tooltip` event listeners.\n     *\n     * @param add when `true`, event listeners are added\n     */\n    d(this, \"_toggleEventListeners\", e => {\n      const n = e ? _ : B,\n        {\n          element: o,\n          options: i,\n          btn: c\n        } = this,\n        {\n          trigger: a\n        } = i,\n        r = !!(this.name !== Pt && i.dismissible);\n      a.includes(\"manual\") || (this.enabled = !!e, a.split(\" \").forEach(p => {\n        p === jo ? (n(o, Mn, this.handleShow), n(o, Me, this.handleShow), r || (n(o, $s, this.handleHide), n(E(o), Ts, this.handleTouch, st))) : p === N ? n(o, p, r ? this.handleShow : this.toggle) : p === ws && (n(o, Es, this.handleShow), r || n(o, On, this.handleHide), Zo && n(o, N, this.handleFocus)), r && c && n(c, N, this.handleHide);\n      }));\n    });\n    const {\n        element: o\n      } = this,\n      i = this.name === Pt,\n      c = i ? lt : It,\n      a = i ? Pt : Ke;\n    un = r => F(r, a), this.enabled = !0, this.id = `${c}-${Wn(o, c)}`;\n    const {\n      options: l\n    } = this;\n    !l.title && i || !i && !l.content || (dt(bs, {\n      titleAttr: \"\"\n    }), Ie(o, Ho) && i && typeof l.title == \"string\" && Po(this, l.title), this.container = pc(o), this.offsetParent = [\"sticky\", \"fixed\"].some(r => V(this.container, \"position\") === r) ? this.container : E(this.element).body, gc(this), this._toggleEventListeners(!0));\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return Pt;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return bs;\n  }\n  show() {\n    const {\n        options: e,\n        tooltip: n,\n        element: o,\n        container: i,\n        offsetParent: c,\n        id: a\n      } = this,\n      {\n        animation: l\n      } = e,\n      r = u.get(o, \"out\"),\n      f = i === c ? i : c;\n    u.clear(o, \"out\"), n && !r && !ee(this) && u.set(o, () => {\n      const p = $(`show.bs.${Xt(this.name)}`);\n      w(o, p), p.defaultPrevented || (ao(n, f), O(o, Nn, `#${a}`), this.update(), bn(this, !0), h(n, m) || g(n, m), l ? x(n, () => mn(this)) : mn(this));\n    }, 17, \"in\");\n  }\n  hide() {\n    const {\n        options: e,\n        tooltip: n,\n        element: o\n      } = this,\n      {\n        animation: i,\n        delay: c\n      } = e;\n    u.clear(o, \"in\"), n && ee(this) && u.set(o, () => {\n      const a = $(`hide.bs.${Xt(this.name)}`);\n      w(o, a), a.defaultPrevented || (this.update(), b(n, m), bn(this), i ? x(n, () => vn(this)) : vn(this));\n    }, c + 17, \"out\");\n  }\n  /** Enables the tooltip. */\n  enable() {\n    const {\n      enabled: e\n    } = this;\n    e || (this._toggleEventListeners(!0), this.enabled = !e);\n  }\n  /** Disables the tooltip. */\n  disable() {\n    const {\n        tooltip: e,\n        options: n,\n        enabled: o\n      } = this,\n      {\n        animation: i\n      } = n;\n    o && (e && ee(this) && i ? (this.hide(), x(e, () => this._toggleEventListeners())) : this._toggleEventListeners(), this.enabled = !o);\n  }\n  /** Toggles the `disabled` property. */\n  toggleEnabled() {\n    this.enabled ? this.disable() : this.enable();\n  }\n  /** Removes the `Tooltip` from the target element. */\n  dispose() {\n    const {\n        tooltip: e,\n        options: n\n      } = this,\n      o = {\n        ...this,\n        name: this.name\n      },\n      i = () => setTimeout(() => bc(o, () => super.dispose()), 17);\n    n.animation && ee(o) ? (this.options.delay = 0, this.hide(), x(e, i)) : i();\n  }\n}\nd(Dt, \"selector\", uc), d(Dt, \"init\", mc), d(Dt, \"getInstance\", un), d(Dt, \"styleTip\", vs);\nconst wc = `[${ct}=\"${It}\"],[data-tip=\"${It}\"]`,\n  Ec = dt({}, bs, {\n    template: yo(It),\n    content: \"\",\n    dismissible: !1,\n    btnClose: '<button class=\"btn-close\" aria-label=\"Close\"></button>'\n  }),\n  $c = t => F(t, Ke),\n  Tc = t => new zt(t);\nclass zt extends Dt {\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(e, n) {\n    super(e, n);\n    /* extend original `show()` */\n    d(this, \"show\", () => {\n      super.show();\n      const {\n        options: e,\n        btn: n\n      } = this;\n      e.dismissible && n && setTimeout(() => ht(n), 17);\n    });\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return Ke;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return Ec;\n  }\n}\nd(zt, \"selector\", wc), d(zt, \"init\", Tc), d(zt, \"getInstance\", $c), d(zt, \"styleTip\", vs);\nconst yc = \"scrollspy\",\n  Do = \"ScrollSpy\",\n  Cc = '[data-bs-spy=\"scroll\"]',\n  Sc = {\n    offset: 10,\n    target: null\n  },\n  Hc = t => F(t, Do),\n  xc = t => new de(t),\n  wn = $(`activate.bs.${yc}`),\n  Pc = t => {\n    const {\n        target: s,\n        scrollTarget: e,\n        options: n,\n        itemsLength: o,\n        scrollHeight: i,\n        element: c\n      } = t,\n      {\n        offset: a\n      } = n,\n      l = Cs(e),\n      r = s && Ss(\"A\", s),\n      f = e ? Ao(e) : ( /* istanbul ignore next */\n      i);\n    if (t.scrollTop = l ? e.scrollY : e.scrollTop, r && (f !== i || o !== r.length)) {\n      let p, v, D;\n      t.items = [], t.offsets = [], t.scrollHeight = f, t.maxScroll = t.scrollHeight - Dc(t), [...r].forEach(q => {\n        p = it(q, \"href\"), v = p && p.charAt(0) === \"#\" && p.slice(-1) !== \"#\" && P(p, E(c)), v && (t.items.push(q), D = we(v), t.offsets.push((l ? D.top + t.scrollTop : v.offsetTop) - a));\n      }), t.itemsLength = t.items.length;\n    }\n  },\n  Ao = t => y(t) ? t.scrollHeight : ft(t).scrollHeight,\n  Dc = ({\n    element: t,\n    scrollTarget: s\n  }) => Cs(s) ? s.innerHeight : we(t).height,\n  Lo = t => {\n    [...Ss(\"A\", t)].forEach(s => {\n      h(s, C) && b(s, C);\n    });\n  },\n  En = (t, s) => {\n    const {\n      target: e,\n      element: n\n    } = t;\n    y(e) && Lo(e), t.activeItem = s, g(s, C);\n    const o = [];\n    let i = s;\n    for (; i !== St(n);) i = i.parentElement, (h(i, \"nav\") || h(i, \"dropdown-menu\")) && o.push(i);\n    o.forEach(c => {\n      const a = c.previousElementSibling;\n      a && !h(a, C) && g(a, C);\n    }), wn.relatedTarget = s, w(n, wn);\n  };\nclass de extends nt {\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(e, n) {\n    super(e, n);\n    /* eslint-enable */\n    // SCROLLSPY PUBLIC METHODS\n    // ========================\n    /** Updates all items. */\n    d(this, \"refresh\", () => {\n      const {\n        target: e\n      } = this;\n      if (y(e) && e.offsetHeight > 0) {\n        Pc(this);\n        const {\n          scrollTop: n,\n          maxScroll: o,\n          itemsLength: i,\n          items: c,\n          activeItem: a\n        } = this;\n        if (n >= o) {\n          const r = c[i - 1];\n          a !== r && En(this, r);\n          return;\n        }\n        const {\n          offsets: l\n        } = this;\n        if (a && n < l[0] && l[0] > 0) {\n          this.activeItem = null, e && Lo(e);\n          return;\n        }\n        c.forEach((r, f) => {\n          a !== r && n >= l[f] && (typeof l[f + 1] > \"u\" || n < l[f + 1]) && En(this, r);\n        });\n      }\n    });\n    /**\n     * Toggles on/off the component event listener.\n     *\n     * @param add when `true`, listener is added\n     */\n    d(this, \"_toggleEventListeners\", e => {\n      (e ? _ : B)(this.scrollTarget, Be, this.refresh, st);\n    });\n    const {\n      element: o,\n      options: i\n    } = this;\n    this.target = P(i.target, E(o)), this.target && (this.scrollTarget = o.clientHeight < o.scrollHeight ? o : qt(o), this.scrollHeight = Ao(this.scrollTarget), this._toggleEventListeners(!0), this.refresh());\n  }\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return Do;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return Sc;\n  }\n  /** Removes `ScrollSpy` from the target element. */\n  dispose() {\n    this._toggleEventListeners(), super.dispose();\n  }\n}\nd(de, \"selector\", Cc), d(de, \"init\", xc), d(de, \"getInstance\", Hc);\nconst $e = \"tab\",\n  Io = \"Tab\",\n  $n = `[${ct}=\"${$e}\"]`,\n  ko = t => F(t, Io),\n  Ac = t => new he(t),\n  is = $(`show.bs.${$e}`),\n  Tn = $(`shown.bs.${$e}`),\n  cs = $(`hide.bs.${$e}`),\n  yn = $(`hidden.bs.${$e}`),\n  me = /* @__PURE__ */new Map(),\n  Cn = t => {\n    const {\n      tabContent: s,\n      nav: e\n    } = t;\n    s && h(s, Nt) && (s.style.height = \"\", b(s, Nt)), e && u.clear(e);\n  },\n  Sn = t => {\n    const {\n        element: s,\n        tabContent: e,\n        content: n,\n        nav: o\n      } = t,\n      {\n        tab: i\n      } = y(o) && me.get(o) || /* istanbul ignore next */\n      {\n        tab: null\n      };\n    if (e && n && h(n, R)) {\n      const {\n        currentHeight: c,\n        nextHeight: a\n      } = me.get(s) || /* istanbul ignore next */\n      {\n        currentHeight: 0,\n        nextHeight: 0\n      };\n      c === a ? Cn(t) : setTimeout(() => {\n        e.style.height = `${a}px`, Mt(e), x(e, () => Cn(t));\n      }, 50);\n    } else o && u.clear(o);\n    Tn.relatedTarget = i, w(s, Tn);\n  },\n  Hn = t => {\n    const {\n        element: s,\n        content: e,\n        tabContent: n,\n        nav: o\n      } = t,\n      {\n        tab: i,\n        content: c\n      } = o && me.get(o) || /* istanbul ignore next */\n      {\n        tab: null,\n        content: null\n      };\n    let a = 0;\n    if (n && e && h(e, R) && ([c, e].forEach(l => {\n      y(l) && g(l, \"overflow-hidden\");\n    }), a = y(c) ? c.scrollHeight : ( /* istanbul ignore next */\n    0)), is.relatedTarget = i, yn.relatedTarget = s, w(s, is), !is.defaultPrevented) {\n      if (e && g(e, C), c && b(c, C), n && e && h(e, R)) {\n        const l = e.scrollHeight;\n        me.set(s, {\n          currentHeight: a,\n          nextHeight: l,\n          tab: null,\n          content: null\n        }), g(n, Nt), n.style.height = `${a}px`, Mt(n), [c, e].forEach(r => {\n          r && b(r, \"overflow-hidden\");\n        });\n      }\n      e && e && h(e, R) ? setTimeout(() => {\n        g(e, m), x(e, () => {\n          Sn(t);\n        });\n      }, 1) : (e && g(e, m), Sn(t)), i && w(i, yn);\n    }\n  },\n  xn = t => {\n    const {\n      nav: s\n    } = t;\n    if (!y(s)) return {\n      tab: null,\n      content: null\n    };\n    const e = rt(C, s);\n    let n = null;\n    e.length === 1 && !Ot.some(i => h(e[0].parentElement, i)) ? [n] = e : e.length > 1 && (n = e[e.length - 1]);\n    const o = y(n) ? X(n) : null;\n    return {\n      tab: n,\n      content: o\n    };\n  },\n  Pn = t => {\n    if (!y(t)) return null;\n    const s = M(t, `.${Ot.join(\",.\")}`);\n    return s ? P(`.${Ot[0]}-toggle`, s) : null;\n  },\n  Lc = t => {\n    const s = ko(t.target);\n    s && (t.preventDefault(), s.show());\n  };\nclass he extends nt {\n  /** @param target the target element */\n  constructor(e) {\n    super(e);\n    /**\n     * Toggles on/off the `click` event listener.\n     *\n     * @param add when `true`, event listener is added\n     */\n    d(this, \"_toggleEventListeners\", e => {\n      (e ? _ : B)(this.element, N, Lc);\n    });\n    const {\n        element: n\n      } = this,\n      o = X(n);\n    if (o) {\n      const i = M(n, \".nav\"),\n        c = M(o, \".tab-content\");\n      this.nav = i, this.content = o, this.tabContent = c, this.dropdown = Pn(n);\n      const {\n        tab: a\n      } = xn(this);\n      if (i && !a) {\n        const l = P($n, i),\n          r = l && X(l);\n        r && (g(l, C), g(r, m), g(r, C), O(n, Qe, \"true\"));\n      }\n      this._toggleEventListeners(!0);\n    }\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return Io;\n  }\n  // TAB PUBLIC METHODS\n  // ==================\n  /** Shows the tab to the user. */\n  show() {\n    const {\n      element: e,\n      content: n,\n      nav: o,\n      dropdown: i\n    } = this;\n    if (!(o && u.get(o)) && !h(e, C)) {\n      const {\n        tab: c,\n        content: a\n      } = xn(this);\n      if (o && me.set(o, {\n        tab: c,\n        content: a,\n        currentHeight: 0,\n        nextHeight: 0\n      }), cs.relatedTarget = e, y(c) && (w(c, cs), !cs.defaultPrevented)) {\n        g(e, C), O(e, Qe, \"true\");\n        const l = y(c) && Pn(c);\n        if (l && h(l, C) && b(l, C), o) {\n          const r = () => {\n            c && (b(c, C), O(c, Qe, \"false\")), i && !h(i, C) && g(i, C);\n          };\n          a && (h(a, R) || n && h(n, R)) ? u.set(o, r, 1) : r();\n        }\n        a && (b(a, m), h(a, R) ? x(a, () => Hn(this)) : Hn(this));\n      }\n    }\n  }\n  /** Removes the `Tab` component from the target element. */\n  dispose() {\n    this._toggleEventListeners(), super.dispose();\n  }\n}\nd(he, \"selector\", $n), d(he, \"init\", Ac), d(he, \"getInstance\", ko);\nconst G = \"toast\",\n  No = \"Toast\",\n  Ic = `.${G}`,\n  kc = `[${We}=\"${G}\"]`,\n  Oo = `[${ct}=\"${G}\"]`,\n  Ut = \"showing\",\n  Mo = \"hide\",\n  Nc = {\n    animation: !0,\n    autohide: !0,\n    delay: 5e3\n  },\n  Is = t => F(t, No),\n  Oc = t => new fe(t),\n  Dn = $(`show.bs.${G}`),\n  Mc = $(`shown.bs.${G}`),\n  An = $(`hide.bs.${G}`),\n  _c = $(`hidden.bs.${G}`),\n  Ln = t => {\n    const {\n      element: s,\n      options: e\n    } = t;\n    b(s, Ut), u.clear(s, Ut), w(s, Mc), e.autohide && u.set(s, () => t.hide(), e.delay, G);\n  },\n  In = t => {\n    const {\n      element: s\n    } = t;\n    b(s, Ut), b(s, m), g(s, Mo), u.clear(s, G), w(s, _c);\n  },\n  Bc = t => {\n    const {\n      element: s,\n      options: e\n    } = t;\n    g(s, Ut), e.animation ? (Mt(s), x(s, () => In(t))) : In(t);\n  },\n  Rc = t => {\n    const {\n      element: s,\n      options: e\n    } = t;\n    u.set(s, () => {\n      b(s, Mo), Mt(s), g(s, m), g(s, Ut), e.animation ? x(s, () => Ln(t)) : Ln(t);\n    }, 17, Ut);\n  },\n  Wc = t => {\n    u.clear(t.element, G), t._toggleEventListeners();\n  },\n  Fc = t => {\n    const {\n        target: s\n      } = t,\n      e = s && M(s, Oo),\n      n = e && X(e),\n      o = n && Is(n);\n    o && (e && e.tagName === \"A\" && t.preventDefault(), o.relatedTarget = e, o.show());\n  },\n  jc = t => {\n    const s = t.target,\n      e = Is(s),\n      {\n        type: n,\n        relatedTarget: o\n      } = t;\n    e && s !== o && !s.contains(o) && ([Me, Es].includes(n) ? u.clear(s, G) : u.set(s, () => e.hide(), e.options.delay, G));\n  };\nclass fe extends nt {\n  /**\n   * @param target the target `.toast` element\n   * @param config the instance options\n   */\n  constructor(e, n) {\n    super(e, n);\n    // TOAST PUBLIC METHODS\n    // ====================\n    /** Shows the toast. */\n    d(this, \"show\", () => {\n      const {\n        element: e,\n        isShown: n\n      } = this;\n      e && !n && (w(e, Dn), Dn.defaultPrevented || Rc(this));\n    });\n    /** Hides the toast. */\n    d(this, \"hide\", () => {\n      const {\n        element: e,\n        isShown: n\n      } = this;\n      e && n && (w(e, An), An.defaultPrevented || Bc(this));\n    });\n    /**\n     * Toggles on/off the `click` event listener.\n     *\n     * @param add when `true`, it will add the listener\n     */\n    d(this, \"_toggleEventListeners\", e => {\n      const n = e ? _ : B,\n        {\n          element: o,\n          triggers: i,\n          dismiss: c,\n          options: a,\n          hide: l\n        } = this;\n      c && n(c, N, l), a.autohide && [Es, On, Me, $s].forEach(r => n(o, r, jc)), i.length && i.forEach(r => n(r, N, Fc));\n    });\n    const {\n      element: o,\n      options: i\n    } = this;\n    i.animation && !h(o, R) ? g(o, R) : !i.animation && h(o, R) && b(o, R), this.dismiss = P(kc, o), this.triggers = [...tt(Oo, E(o))].filter(c => X(c) === o), this._toggleEventListeners(!0);\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return No;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return Nc;\n  }\n  /**\n   * Returns *true* when toast is visible.\n   */\n  get isShown() {\n    return h(this.element, m);\n  }\n  /** Removes the `Toast` component from the target element. */\n  dispose() {\n    const {\n      element: e,\n      isShown: n\n    } = this;\n    n && b(e, m), Wc(this), super.dispose();\n  }\n}\nd(fe, \"selector\", Ic), d(fe, \"init\", Oc), d(fe, \"getInstance\", Is);\nconst ks = /* @__PURE__ */new Map();\n[ne, oe, ie, ce, ae, re, le, zt, de, he, fe, Dt].forEach(t => ks.set(t.prototype.name, t));\nconst zc = (t, s) => {\n    [...s].forEach(e => t(e));\n  },\n  Vc = (t, s) => {\n    const e = At.getAllFor(t);\n    e && [...e].forEach(([n, o]) => {\n      s.contains(n) && o.dispose();\n    });\n  },\n  kn = t => {\n    const s = t && t.nodeName ? t : document,\n      e = [...Ss(\"*\", s)];\n    ks.forEach(n => {\n      const {\n        init: o,\n        selector: i\n      } = n;\n      zc(o, e.filter(c => jn(c, i)));\n    });\n  },\n  Xc = t => {\n    const s = t && t.nodeName ? t : document;\n    ks.forEach(e => {\n      Vc(e.prototype.name, s);\n    });\n  };\ndocument.body ? kn() : _(document, \"DOMContentLoaded\", () => kn(), {\n  once: !0\n});\nexport { ne as Alert, oe as Button, ie as Carousel, ce as Collapse, ae as Dropdown, re as Modal, le as Offcanvas, zt as Popover, de as ScrollSpy, he as Tab, fe as Toast, Dt as Tooltip, kn as initCallback, Xc as removeDataAPI };","map":{"version":3,"names":["Nn","De","ke","Ne","Ns","Qe","Wo","ws","Es","On","Oe","Fo","N","Mn","jo","Me","$s","zo","Vo","Ko","_e","Be","Ts","Xo","as","rs","Os","Ms","ys","Yo","Uo","Ze","_n","qo","navigator","userAgentData","Ae","userAgent","Qo","Le","_s","brands","some","t","test","brand","Bs","Zo","includes","head","Re","document","style","Go","Gt","s","e","n","o","addEventListener","Jo","Jt","removeEventListener","ti","Kt","i","target","currentTarget","apply","ge","Xt","Object","defineProperty","get","it","Yt","getAttribute","Ie","kn","hasAttribute","O","Tn","setAttribute","kt","Cn","removeAttribute","g","Ln","classList","add","b","In","remove","h","zn","contains","ve","L","nodeType","y","Ft","Map","At","data","set","has","getAllFor","delete","size","F","Hn","be","Cs","constructor","name","Bn","E","ownerDocument","window","dt","M","assign","$t","createElement","tagName","w","Q","dispatchEvent","V","getComputedStyle","replace","toLowerCase","getPropertyValue","ei","parseFloat","Number","isNaN","x","Un","Event","c","a","setTimeout","ht","Qn","focus","Rs","Ce","entries","si","jn","dataset","l","forEach","r","f","p","v","Ws","keys","$","Xn","CustomEvent","cancelable","bubbles","st","passive","Mt","offsetHeight","I","$n","setProperty","ls","ni","bt","u","length","clear","clearTimeout","we","width","height","top","right","bottom","left","getBoundingClientRect","offsetWidth","Math","round","St","body","ft","documentElement","Rn","oi","nodeName","assignedSlot","parentNode","host","Fs","js","jt","Wn","ae","id","qt","defaultView","ii","Array","isArray","Fn","clientHeight","ci","ai","Ct","dir","ri","le","closest","getRootNode","P","So","querySelector","Ss","de","getElementsByTagName","tt","Mo","querySelectorAll","rt","To","getElementsByClassName","Do","matches","Vt","type","once","B","_","R","m","We","Fe","Vn","li","di","nt","d","Error","_toggleEventListeners","element","options","defaults","version","dispose","hi","fi","gi","pi","ne","zs","ui","Vs","defaultPrevented","dismiss","close","C","ct","mi","Kn","vi","bi","wi","oe","preventDefault","isActive","toggle","String","ds","Lt","Ks","Ei","X","map","filter","Ee","hs","Et","Tt","Xs","pause","keyboard","touch","interval","gt","$i","ie","se","Se","Ge","Je","fs","Ys","index","direction","slides","isAnimating","gs","cycle","hidden","isPaused","Ti","yi","Ci","to","Si","next","prev","Hi","carouselKeyHandler","code","Us","isTouch","indicator","controls","stopImmediatePropagation","stopPropagation","xi","indicators","every","pageX","Yn","Pi","Di","find","getSelection","toString","abs","ts","activateCarouselIndicator","toggleCarouselTouchHandlers","indexOf","D","relatedTarget","from","Nt","K","Ai","qn","Li","parent","He","Ii","ce","qs","ki","Qs","Ni","Oi","triggers","scrollHeight","Zs","Mi","hide","show","Ot","Zn","Gn","slice","et","ps","us","ms","Jn","_i","Bi","Gs","Js","tn","Ri","offset","display","es","en","ss","sn","eo","menu","parentElement","k","ut","dropdown","dropup","dropstart","dropend","menuStart","menuEnd","clientWidth","q","T","j","Y","Bt","at","S","J","ot","W","z","H","Rt","pt","margin","join","Wi","children","firstElementChild","nn","open","on","ji","zi","Vi","je","Fi","activeElement","U","Hs","xs","Ki","Xi","so","no","oo","Yi","paddingRight","overflow","marginRight","io","innerWidth","co","setScrollbar","parseInt","Z","yt","className","ao","appendPopup","append","ro","removePopup","Ps","hasPopup","lo","cn","an","ho","Ds","A","_t","As","fo","appendOverlay","go","showOverlay","ze","hideOverlay","po","uo","offsetParent","Ui","mo","qi","vo","Qi","backdrop","pe","Zi","re","xe","rn","ns","ln","bo","wo","toggleModalDismiss","update","tc","Ji","dn","hn","fn","hasFade","gn","Gi","modalKeyHandler","isStatic","modalDialog","ec","callback","sc","Ls","nc","Ve","oc","scroll","ue","ic","Pe","Eo","os","$o","cc","toggleOffCanvasDismiss","dc","lc","pn","visibility","hc","ac","blur","fc","rc","offcanvasKeyDismissHandler","It","Ke","lt","yo","Co","vs","tooltip","container","arrow","placement","Ht","Qt","mt","Xe","Wt","Te","Ye","xt","vt","Ue","Zt","te","ye","qe","_o","bs","template","title","customClass","trigger","sanitizeFn","animation","delay","content","dismissible","btnClose","Pt","wt","setHtml","trim","DOMParser","parseFromString","childNodes","gc","firstChild","cloneNode","btn","pc","push","uc","Ho","un","mc","Dt","vc","ee","bc","disposeTooltipComplete","Po","xo","toggleTooltipAction","handleTouch","mn","vn","bn","toggleTooltipOpenHandlers","handleHide","toggleTooltipTitle","enabled","split","handleShow","handleFocus","titleAttr","enable","disable","toggleEnabled","wc","Ec","$c","Tc","zt","yc","Cc","Sc","Hc","xc","wn","Pc","scrollTarget","itemsLength","Ao","scrollTop","scrollY","items","offsets","maxScroll","Dc","charAt","offsetTop","getOffsetHeight","innerHeight","Lo","En","activate","activeItem","previousElementSibling","refresh","$e","Io","ko","Ac","he","is","cs","yn","me","tabContent","nav","Sn","tab","currentHeight","nextHeight","xn","Pn","Lc","toggleTab","G","No","Ic","kc","Oo","Ut","Nc","autohide","Is","Oc","fe","Dn","Mc","An","_c","Bc","Rc","Wc","Fc","jc","isShown","ks","prototype","zc","initComponentDataAPI","Vc","removeComponentDataAPI","init","selector","Xc"],"sources":["../node_modules/.pnpm/@thednp+shorty@2.0.0/node_modules/@thednp/shorty/dist/shorty.mjs","../node_modules/.pnpm/@thednp+event-listener@2.0.4/node_modules/@thednp/event-listener/dist/event-listener.mjs","../src/strings/fadeClass.ts","../src/strings/showClass.ts","../src/strings/dataBsDismiss.ts","../src/strings/alertString.ts","../src/strings/alertComponent.ts","../src/version.ts","../src/components/base-component.ts","../src/components/alert.ts","../src/strings/activeClass.ts","../src/strings/dataBsToggle.ts","../src/strings/buttonString.ts","../src/strings/buttonComponent.ts","../src/components/button.ts","../src/strings/dataBsTarget.ts","../src/strings/carouselString.ts","../src/strings/carouselComponent.ts","../src/strings/dataBsParent.ts","../src/strings/dataBsContainer.ts","../src/util/getTargetElement.ts","../src/components/carousel.ts","../src/strings/collapsingClass.ts","../src/strings/collapseString.ts","../src/strings/collapseComponent.ts","../src/components/collapse.ts","../src/strings/dropdownClasses.ts","../src/strings/dropdownComponent.ts","../src/strings/dropdownMenuClass.ts","../src/util/isEmptyAnchor.ts","../src/components/dropdown.ts","../src/strings/modalString.ts","../src/strings/modalComponent.ts","../src/strings/offcanvasComponent.ts","../src/strings/fixedTopClass.ts","../src/strings/fixedBottomClass.ts","../src/strings/stickyTopClass.ts","../src/strings/positionStickyClass.ts","../src/util/scrollbar.ts","../src/strings/offcanvasString.ts","../src/util/popupContainer.ts","../src/util/backdrop.ts","../src/util/isVisible.ts","../src/components/modal.ts","../src/components/offcanvas.ts","../src/strings/popoverString.ts","../src/strings/popoverComponent.ts","../src/strings/tooltipString.ts","../src/util/getTipTemplate.ts","../src/util/tipClassPositions.ts","../src/util/styleTip.ts","../src/util/tooltipDefaults.ts","../src/strings/dataOriginalTitle.ts","../src/strings/tooltipComponent.ts","../src/util/setHtml.ts","../src/util/createTip.ts","../src/util/getElementContainer.ts","../src/components/tooltip.ts","../src/components/popover.ts","../src/strings/scrollspyString.ts","../src/strings/scrollspyComponent.ts","../src/components/scrollspy.ts","../src/strings/tabString.ts","../src/strings/tabComponent.ts","../src/components/tab.ts","../src/strings/toastString.ts","../src/strings/toastComponent.ts","../src/components/toast.ts","../src/util/init.ts"],"sourcesContent":["const pe = \"aria-checked\", me = \"aria-description\", fe = \"aria-describedby\", ge = \"aria-expanded\", ve = \"aria-haspopup\", Ee = \"aria-hidden\", be = \"aria-label\", he = \"aria-labelledby\", ye = \"aria-modal\", we = \"aria-pressed\", Ae = \"aria-selected\", Se = \"aria-valuemin\", Ne = \"aria-valuemax\", ke = \"aria-valuenow\", Me = \"aria-valuetext\", q = \"abort\", G = \"beforeunload\", J = \"blur\", K = \"change\", X = \"contextmenu\", P = \"DOMContentLoaded\", Y = \"DOMMouseScroll\", Z = \"error\", $ = \"focus\", _ = \"focusin\", tt = \"focusout\", et = \"gesturechange\", nt = \"gestureend\", ot = \"gesturestart\", st = \"keydown\", ct = \"keypress\", rt = \"keyup\", at = \"load\", it = \"click\", ut = \"dblclick\", lt = \"mousedown\", dt = \"mouseup\", pt = \"hover\", mt = \"mouseenter\", ft = \"mouseleave\", gt = \"mousein\", vt = \"mouseout\", Et = \"mouseover\", bt = \"mousemove\", ht = \"mousewheel\", yt = \"move\", wt = \"orientationchange\", At = \"pointercancel\", St = \"pointerdown\", Nt = \"pointerleave\", kt = \"pointermove\", Mt = \"pointerup\", Tt = \"readystatechange\", Dt = \"reset\", Ct = \"resize\", Ot = \"select\", Lt = \"selectend\", It = \"selectstart\", zt = \"scroll\", xt = \"submit\", Vt = \"touchstart\", Bt = \"touchmove\", Ht = \"touchcancel\", Pt = \"touchend\", Ft = \"unload\", Te = {\n  DOMContentLoaded: P,\n  DOMMouseScroll: Y,\n  abort: q,\n  beforeunload: G,\n  blur: J,\n  change: K,\n  click: it,\n  contextmenu: X,\n  dblclick: ut,\n  error: Z,\n  focus: $,\n  focusin: _,\n  focusout: tt,\n  gesturechange: et,\n  gestureend: nt,\n  gesturestart: ot,\n  hover: pt,\n  keydown: st,\n  keypress: ct,\n  keyup: rt,\n  load: at,\n  mousedown: lt,\n  mousemove: bt,\n  mousein: gt,\n  mouseout: vt,\n  mouseenter: mt,\n  mouseleave: ft,\n  mouseover: Et,\n  mouseup: dt,\n  mousewheel: ht,\n  move: yt,\n  orientationchange: wt,\n  pointercancel: At,\n  pointerdown: St,\n  pointerleave: Nt,\n  pointermove: kt,\n  pointerup: Mt,\n  readystatechange: Tt,\n  reset: Dt,\n  resize: Ct,\n  scroll: zt,\n  select: Ot,\n  selectend: Lt,\n  selectstart: It,\n  submit: xt,\n  touchcancel: Ht,\n  touchend: Pt,\n  touchmove: Bt,\n  touchstart: Vt,\n  unload: Ft\n}, De = \"drag\", Ce = \"dragstart\", Oe = \"dragenter\", Le = \"dragleave\", Ie = \"dragover\", ze = \"dragend\", xe = \"loadstart\", Ve = {\n  start: \"mousedown\",\n  end: \"mouseup\",\n  move: \"mousemove\",\n  cancel: \"mouseleave\"\n}, Be = { down: \"mousedown\", up: \"mouseup\" }, He = \"onmouseleave\" in document ? [\"mouseenter\", \"mouseleave\"] : (\n  /* istanbul ignore next */\n  [\"mouseover\", \"mouseout\"]\n), Pe = {\n  start: \"touchstart\",\n  end: \"touchend\",\n  move: \"touchmove\",\n  cancel: \"touchcancel\"\n}, Fe = { in: \"focusin\", out: \"focusout\" }, Ue = {\n  Backspace: \"Backspace\",\n  //  8\n  Tab: \"Tab\",\n  //  9\n  Enter: \"Enter\",\n  // 13\n  Shift: \"Shift\",\n  // 16\n  Control: \"Control\",\n  // 17\n  Alt: \"Alt\",\n  // 18\n  Pause: \"Pause\",\n  // 19\n  CapsLock: \"CapsLock\",\n  // 20\n  Escape: \"Escape\",\n  // 27\n  Scape: \"Space\",\n  // 32\n  ArrowLeft: \"ArrowLeft\",\n  // 37\n  ArrowUp: \"ArrowUp\",\n  // 38\n  ArrowRight: \"ArrowRight\",\n  // 39\n  ArrowDown: \"ArrowDown\",\n  // 40\n  Insert: \"Insert\",\n  // 45\n  Delete: \"Delete\",\n  // 46\n  Meta: \"Meta\",\n  // 91 windows key\n  ContextMenu: \"ContextMenu\",\n  // 93\n  ScrollLock: \"ScrollLock\"\n  // 145\n}, We = \"Alt\", Re = \"ArrowDown\", Qe = \"ArrowUp\", je = \"ArrowLeft\", qe = \"ArrowRight\", Ge = \"Backspace\", Je = \"CapsLock\", Ke = \"Control\", Xe = \"Delete\", Ye = \"Enter\", Ze = \"NumpadEnter\", $e = \"Escape\", _e = \"Insert\", tn = \"Meta\", en = \"Pause\", nn = \"ScrollLock\", on = \"Shift\", sn = \"Space\", cn = \"Tab\", Ut = \"animationDuration\", Wt = \"animationDelay\", F = \"animationName\", D = \"animationend\", Rt = \"transitionDuration\", Qt = \"transitionDelay\", C = \"transitionend\", U = \"transitionProperty\", rn = \"addEventListener\", an = \"removeEventListener\", un = {\n  linear: \"linear\",\n  easingSinusoidalIn: \"cubic-bezier(0.47,0,0.745,0.715)\",\n  easingSinusoidalOut: \"cubic-bezier(0.39,0.575,0.565,1)\",\n  easingSinusoidalInOut: \"cubic-bezier(0.445,0.05,0.55,0.95)\",\n  easingQuadraticIn: \"cubic-bezier(0.550,0.085,0.680,0.530)\",\n  easingQuadraticOut: \"cubic-bezier(0.250,0.460,0.450,0.940)\",\n  easingQuadraticInOut: \"cubic-bezier(0.455,0.030,0.515,0.955)\",\n  easingCubicIn: \"cubic-bezier(0.55,0.055,0.675,0.19)\",\n  easingCubicOut: \"cubic-bezier(0.215,0.61,0.355,1)\",\n  easingCubicInOut: \"cubic-bezier(0.645,0.045,0.355,1)\",\n  easingQuarticIn: \"cubic-bezier(0.895,0.03,0.685,0.22)\",\n  easingQuarticOut: \"cubic-bezier(0.165,0.84,0.44,1)\",\n  easingQuarticInOut: \"cubic-bezier(0.77,0,0.175,1)\",\n  easingQuinticIn: \"cubic-bezier(0.755,0.05,0.855,0.06)\",\n  easingQuinticOut: \"cubic-bezier(0.23,1,0.32,1)\",\n  easingQuinticInOut: \"cubic-bezier(0.86,0,0.07,1)\",\n  easingExponentialIn: \"cubic-bezier(0.95,0.05,0.795,0.035)\",\n  easingExponentialOut: \"cubic-bezier(0.19,1,0.22,1)\",\n  easingExponentialInOut: \"cubic-bezier(1,0,0,1)\",\n  easingCircularIn: \"cubic-bezier(0.6,0.04,0.98,0.335)\",\n  easingCircularOut: \"cubic-bezier(0.075,0.82,0.165,1)\",\n  easingCircularInOut: \"cubic-bezier(0.785,0.135,0.15,0.86)\",\n  easingBackIn: \"cubic-bezier(0.6,-0.28,0.735,0.045)\",\n  easingBackOut: \"cubic-bezier(0.175,0.885,0.32,1.275)\",\n  easingBackInOut: \"cubic-bezier(0.68,-0.55,0.265,1.55)\"\n}, ln = \"offsetHeight\", dn = \"offsetWidth\", pn = \"scrollHeight\", mn = \"scrollWidth\", fn = \"tabindex\", jt = navigator.userAgentData, A = jt, { userAgent: qt } = navigator, S = qt, z = /iPhone|iPad|iPod|Android/i;\nlet O = !1;\nA ? O = A.brands.some((t) => z.test(t.brand)) : O = z.test(S);\nconst gn = O, x = /(iPhone|iPod|iPad)/, vn = A ? A.brands.some((t) => x.test(t.brand)) : (\n  /* istanbul ignore next */\n  x.test(S)\n), En = S ? S.includes(\"Firefox\") : (\n  /* istanbul ignore next */\n  !1\n), { head: N } = document, bn = [\"webkitPerspective\", \"perspective\"].some((t) => t in N.style), Gt = (t, e, n, o) => {\n  const s = o || !1;\n  t.addEventListener(e, n, s);\n}, Jt = (t, e, n, o) => {\n  const s = o || !1;\n  t.removeEventListener(e, n, s);\n}, Kt = (t, e, n, o) => {\n  const s = (r) => {\n    (r.target === t || r.currentTarget === t) && (n.apply(t, [r]), Jt(t, e, s, o));\n  };\n  Gt(t, e, s, o);\n}, Xt = () => {\n}, hn = (() => {\n  let t = !1;\n  try {\n    const e = Object.defineProperty({}, \"passive\", {\n      get: () => (t = !0, t)\n    });\n    Kt(document, P, Xt, e);\n  } catch {\n  }\n  return t;\n})(), yn = [\"webkitTransform\", \"transform\"].some((t) => t in N.style), wn = \"ontouchstart\" in window || /* istanbul ignore next */\n\"msMaxTouchPoints\" in navigator, An = [\"webkitAnimation\", \"animation\"].some((t) => t in N.style), Sn = [\"webkitTransition\", \"transition\"].some((t) => t in N.style), Yt = (t, e) => t.getAttribute(e), Nn = (t, e, n) => e.getAttributeNS(t, n), kn = (t, e) => t.hasAttribute(e), Mn = (t, e, n) => e.hasAttributeNS(t, n), Tn = (t, e, n) => t.setAttribute(e, n), Dn = (t, e, n, o) => e.setAttributeNS(t, n, o), Cn = (t, e) => t.removeAttribute(e), On = (t, e, n) => e.removeAttributeNS(t, n), Ln = (t, ...e) => {\n  t.classList.add(...e);\n}, In = (t, ...e) => {\n  t.classList.remove(...e);\n}, zn = (t, e) => t.classList.contains(e), { body: xn } = document, { documentElement: Vn } = document, Bn = (t) => Array.from(t), v = (t) => t != null && typeof t == \"object\" || !1, i = (t) => v(t) && typeof t.nodeType == \"number\" && [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].some((e) => t.nodeType === e) || !1, u = (t) => i(t) && t.nodeType === 1 || !1, E = /* @__PURE__ */ new Map(), L = {\n  data: E,\n  /**\n   * Sets web components data.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   * @param instance the component instance\n   */\n  set: (t, e, n) => {\n    if (!u(t))\n      return;\n    E.has(e) || E.set(e, /* @__PURE__ */ new Map()), E.get(e).set(t, n);\n  },\n  /**\n   * Returns all instances for specified component.\n   *\n   * @param component the component's name or a unique key\n   * @returns all the component instances\n   */\n  getAllFor: (t) => E.get(t) || null,\n  /**\n   * Returns the instance associated with the target.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   * @returns the instance\n   */\n  get: (t, e) => {\n    if (!u(t) || !e)\n      return null;\n    const n = L.getAllFor(e);\n    return t && n && n.get(t) || null;\n  },\n  /**\n   * Removes web components data.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   */\n  remove: (t, e) => {\n    const n = L.getAllFor(e);\n    !n || !u(t) || (n.delete(t), n.size === 0 && E.delete(e));\n  }\n}, Hn = (t, e) => L.get(t, e), k = (t) => typeof t == \"string\" || !1, W = (t) => v(t) && t.constructor.name === \"Window\" || !1, R = (t) => i(t) && t.nodeType === 9 || !1, d = (t) => W(t) ? t.document : R(t) ? t : i(t) ? t.ownerDocument : window.document, M = (t, ...e) => Object.assign(t, ...e), Zt = (t) => {\n  if (!t)\n    return;\n  if (k(t))\n    return d().createElement(t);\n  const { tagName: e } = t, n = Zt(e);\n  if (!n)\n    return;\n  const o = { ...t };\n  return delete o.tagName, M(n, o);\n}, $t = (t, e) => {\n  if (!t || !e)\n    return;\n  if (k(e))\n    return d().createElementNS(t, e);\n  const { tagName: n } = e, o = $t(t, n);\n  if (!o)\n    return;\n  const s = { ...e };\n  return delete s.tagName, M(o, s);\n}, Q = (t, e) => t.dispatchEvent(e), Pn = (t, e, n) => n.indexOf(t) === e, g = (t, e) => {\n  const n = getComputedStyle(t), o = e.replace(\"webkit\", \"Webkit\").replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  return n.getPropertyValue(o);\n}, _t = (t) => {\n  const e = g(t, F), n = g(t, Wt), o = n.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : 0;\n  return Number.isNaN(s) ? (\n    /* istanbul ignore next */\n    0\n  ) : s;\n}, te = (t) => {\n  const e = g(t, F), n = g(t, Ut), o = n.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : 0;\n  return Number.isNaN(s) ? (\n    /* istanbul ignore next */\n    0\n  ) : s;\n}, Fn = (t, e) => {\n  let n = 0;\n  const o = new Event(D), s = te(t), r = _t(t);\n  if (s) {\n    const a = (l) => {\n      l.target === t && (e.apply(t, [l]), t.removeEventListener(D, a), n = 1);\n    };\n    t.addEventListener(D, a), setTimeout(() => {\n      n || Q(t, o);\n    }, s + r + 17);\n  } else\n    e.apply(t, [o]);\n}, ee = (t) => {\n  const e = g(t, U), n = g(t, Qt), o = n.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : (\n    /* istanbul ignore next */\n    0\n  );\n  return Number.isNaN(s) ? (\n    /* istanbul ignore next */\n    0\n  ) : s;\n}, ne = (t) => {\n  const e = g(t, U), n = g(t, Rt), o = n.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : (\n    /* istanbul ignore next */\n    0\n  );\n  return Number.isNaN(s) ? (\n    /* istanbul ignore next */\n    0\n  ) : s;\n}, Un = (t, e) => {\n  let n = 0;\n  const o = new Event(C), s = ne(t), r = ee(t);\n  if (s) {\n    const a = (l) => {\n      l.target === t && (e.apply(t, [l]), t.removeEventListener(C, a), n = 1);\n    };\n    t.addEventListener(C, a), setTimeout(() => {\n      n || Q(t, o);\n    }, s + r + 17);\n  } else\n    e.apply(t, [o]);\n}, Wn = (t) => Float32Array.from(Array.from(t)), Rn = (t) => Float64Array.from(Array.from(t)), Qn = (t, e) => t.focus(e), V = (t) => [\"true\", !0].includes(t) ? !0 : [\"false\", !1].includes(t) ? !1 : [\"null\", \"\", null, void 0].includes(t) ? null : t !== \"\" && !Number.isNaN(+t) ? +t : t, w = (t) => Object.entries(t), oe = (t) => t.toLowerCase(), jn = (t, e, n, o) => {\n  const s = { ...n }, r = { ...t.dataset }, a = { ...e }, l = {}, p = \"title\";\n  return w(r).forEach(([c, m]) => {\n    const y = o && typeof c == \"string\" && c.includes(o) ? c.replace(o, \"\").replace(/[A-Z]/g, (j) => oe(j)) : c;\n    l[y] = V(m);\n  }), w(s).forEach(([c, m]) => {\n    s[c] = V(m);\n  }), w(e).forEach(([c, m]) => {\n    c in s ? a[c] = s[c] : c in l ? a[c] = l[c] : a[c] = c === p ? Yt(t, p) : m;\n  }), a;\n}, qn = (t, e) => v(t) && (Object.hasOwn(t, e) || e in t), Gn = (t) => Object.keys(t), Jn = (t) => Object.values(t), Kn = (t) => Object.fromEntries(t), Xn = (t, e) => {\n  const n = new CustomEvent(t, {\n    cancelable: !0,\n    bubbles: !0\n  });\n  return v(e) && M(n, e), n;\n}, Yn = { passive: !0 }, Zn = (t) => t.offsetHeight, $n = (t, e) => {\n  w(e).forEach(([n, o]) => {\n    if (o && k(n) && n.includes(\"--\"))\n      t.style.setProperty(n, o);\n    else {\n      const s = {};\n      s[n] = o, M(t.style, s);\n    }\n  });\n}, I = (t) => v(t) && t.constructor.name === \"Map\" || !1, se = (t) => typeof t == \"number\" || !1, f = /* @__PURE__ */ new Map(), _n = {\n  /**\n   * Sets a new timeout timer for an element, or element -> key association.\n   *\n   * @param element target element\n   * @param callback the callback\n   * @param delay the execution delay\n   * @param key a unique key\n   */\n  set: (t, e, n, o) => {\n    u(t) && (o && o.length ? (f.has(t) || f.set(t, /* @__PURE__ */ new Map()), f.get(t).set(o, setTimeout(e, n))) : f.set(t, setTimeout(e, n)));\n  },\n  /**\n   * Returns the timer associated with the target.\n   *\n   * @param element target element\n   * @param key a unique\n   * @returns the timer\n   */\n  get: (t, e) => {\n    if (!u(t))\n      return null;\n    const n = f.get(t);\n    return e && n && I(n) ? n.get(e) || /* istanbul ignore next */\n    null : se(n) ? n : null;\n  },\n  /**\n   * Clears the element's timer.\n   *\n   * @param element target element\n   * @param key a unique key\n   */\n  clear: (t, e) => {\n    if (!u(t))\n      return;\n    const n = f.get(t);\n    e && e.length && I(n) ? (clearTimeout(n.get(e)), n.delete(e), n.size === 0 && f.delete(t)) : (clearTimeout(n), f.delete(t));\n  }\n}, to = (t) => t.toUpperCase(), h = (t, e) => {\n  const { width: n, height: o, top: s, right: r, bottom: a, left: l } = t.getBoundingClientRect();\n  let p = 1, c = 1;\n  if (e && u(t)) {\n    const { offsetWidth: m, offsetHeight: y } = t;\n    p = m > 0 ? Math.round(n) / m : (\n      /* istanbul ignore next */\n      1\n    ), c = y > 0 ? Math.round(o) / y : (\n      /* istanbul ignore next */\n      1\n    );\n  }\n  return {\n    width: n / p,\n    height: o / c,\n    top: s / c,\n    right: r / p,\n    bottom: a / c,\n    left: l / p,\n    x: l / p,\n    y: s / c\n  };\n}, eo = (t) => d(t).body, T = (t) => d(t).documentElement, no = (t) => d(t).head, oo = (t) => {\n  const e = W(t), n = e ? t.scrollX : t.scrollLeft, o = e ? t.scrollY : t.scrollTop;\n  return { x: n, y: o };\n}, ce = (t) => i(t) && t.constructor.name === \"ShadowRoot\" || !1, so = (t) => t.nodeName === \"HTML\" ? t : u(t) && t.assignedSlot || // step into the shadow DOM of the parent of a slotted node\ni(t) && t.parentNode || // DOM Element detected\nce(t) && t.host || // ShadowRoot detected\nT(t), re = (t) => {\n  if (!u(t))\n    return !1;\n  const { width: e, height: n } = h(t), { offsetWidth: o, offsetHeight: s } = t;\n  return Math.round(e) !== o || Math.round(n) !== s;\n}, co = (t, e, n) => {\n  const o = u(e), s = h(t, o && re(e)), r = { x: 0, y: 0 };\n  if (o) {\n    const a = h(e, !0);\n    r.x = a.x + e.clientLeft, r.y = a.y + e.clientTop;\n  }\n  return {\n    x: s.left + n.x - r.x,\n    y: s.top + n.y - r.y,\n    width: s.width,\n    height: s.height\n  };\n};\nlet B = 0, H = 0;\nconst b = /* @__PURE__ */ new Map(), ae = (t, e) => {\n  let n = e ? B : H;\n  if (e) {\n    const o = ae(t), s = b.get(o) || /* @__PURE__ */ new Map();\n    b.has(o) || b.set(o, s), I(s) && !s.has(e) ? (s.set(e, n), B += 1) : n = s.get(e);\n  } else {\n    const o = t.id || t;\n    b.has(o) ? n = b.get(o) : (b.set(o, n), H += 1);\n  }\n  return n;\n}, ro = (t) => {\n  var e;\n  return t ? R(t) ? t.defaultView : i(t) ? (e = t == null ? void 0 : t.ownerDocument) == null ? void 0 : e.defaultView : t : window;\n}, ie = (t) => Array.isArray(t) || !1, ao = (t) => i(t) && t.nodeName === \"CANVAS\" || !1, ue = (t) => u(t) && !!t.shadowRoot || !1, io = (t) => i(t) && [1, 2, 3, 4, 5, 6, 7, 8].some((e) => t.nodeType === e) || !1, uo = (t) => {\n  if (!i(t))\n    return !1;\n  const { top: e, bottom: n } = h(t), { clientHeight: o } = T(t);\n  return e <= o && n >= 0;\n}, lo = (t) => {\n  if (!i(t))\n    return !1;\n  const { clientWidth: e, clientHeight: n } = T(t), { top: o, left: s, bottom: r, right: a } = h(t, !0);\n  return o >= 0 && s >= 0 && r <= n && a <= e;\n}, po = (t) => ie(t) && t.every(u) || !1, mo = (t) => typeof t == \"function\" || !1, fo = (t) => v(t) && t.constructor.name === \"HTMLCollection\" || !1, go = (t) => u(t) && t.tagName === \"IMG\" || !1, vo = (t) => {\n  if (!k(t))\n    return !1;\n  try {\n    JSON.parse(t);\n  } catch {\n    return !1;\n  }\n  return !0;\n}, Eo = (t) => v(t) && t.constructor.name === \"WeakMap\" || !1, bo = (t) => i(t) && [\"SVG\", \"Image\", \"Video\", \"Canvas\"].some((e) => t.constructor.name.includes(e)) || !1, ho = (t) => v(t) && t.constructor.name === \"NodeList\" || !1, yo = (t) => T(t).dir === \"rtl\", wo = (t) => i(t) && t.constructor.name.includes(\"SVG\") || !1, Ao = (t) => i(t) && [\"TABLE\", \"TD\", \"TH\"].includes(t.nodeName) || !1, le = (t, e) => t ? t.closest(e) || // break out of `ShadowRoot`\nle(t.getRootNode().host, e) : null, So = (t, e) => u(t) ? t : (i(e) ? e : d()).querySelector(t), de = (t, e) => (i(e) ? e : d()).getElementsByTagName(t), No = (t) => [...de(\"*\", t)].filter(ue), ko = (t, e) => d(e).getElementById(t) || null, Mo = (t, e) => (i(e) ? e : d()).querySelectorAll(t), To = (t, e) => (e && i(e) ? e : d()).getElementsByClassName(\n  t\n), Do = (t, e) => t.matches(e), Co = \"2.0.0\";\nexport {\n  Bn as ArrayFrom,\n  P as DOMContentLoadedEvent,\n  Y as DOMMouseScrollEvent,\n  L as Data,\n  Wn as Float32ArrayFrom,\n  Rn as Float64ArrayFrom,\n  M as ObjectAssign,\n  w as ObjectEntries,\n  Kn as ObjectFromEntries,\n  qn as ObjectHasOwn,\n  Gn as ObjectKeys,\n  Jn as ObjectValues,\n  _n as Timer,\n  q as abortEvent,\n  Ln as addClass,\n  rn as addEventListener,\n  Wt as animationDelay,\n  Ut as animationDuration,\n  D as animationEndEvent,\n  F as animationName,\n  pe as ariaChecked,\n  fe as ariaDescribedBy,\n  me as ariaDescription,\n  ge as ariaExpanded,\n  ve as ariaHasPopup,\n  Ee as ariaHidden,\n  be as ariaLabel,\n  he as ariaLabelledBy,\n  ye as ariaModal,\n  we as ariaPressed,\n  Ae as ariaSelected,\n  Ne as ariaValueMax,\n  Se as ariaValueMin,\n  ke as ariaValueNow,\n  Me as ariaValueText,\n  G as beforeunloadEvent,\n  un as bezierEasings,\n  J as blurEvent,\n  K as changeEvent,\n  le as closest,\n  X as contextmenuEvent,\n  Xn as createCustomEvent,\n  Zt as createElement,\n  $t as createElementNS,\n  Q as dispatchEvent,\n  Pn as distinct,\n  xn as documentBody,\n  Vn as documentElement,\n  N as documentHead,\n  De as dragEvent,\n  ze as dragendEvent,\n  Oe as dragenterEvent,\n  Le as dragleaveEvent,\n  Ie as dragoverEvent,\n  Ce as dragstartEvent,\n  Fn as emulateAnimationEnd,\n  Un as emulateTransitionEnd,\n  Z as errorEvent,\n  Qn as focus,\n  $ as focusEvent,\n  Fe as focusEvents,\n  _ as focusinEvent,\n  tt as focusoutEvent,\n  et as gesturechangeEvent,\n  nt as gestureendEvent,\n  ot as gesturestartEvent,\n  Yt as getAttribute,\n  Nn as getAttributeNS,\n  h as getBoundingClientRect,\n  No as getCustomElements,\n  d as getDocument,\n  eo as getDocumentBody,\n  T as getDocumentElement,\n  no as getDocumentHead,\n  _t as getElementAnimationDelay,\n  te as getElementAnimationDuration,\n  ko as getElementById,\n  g as getElementStyle,\n  ee as getElementTransitionDelay,\n  ne as getElementTransitionDuration,\n  To as getElementsByClassName,\n  de as getElementsByTagName,\n  Hn as getInstance,\n  oo as getNodeScroll,\n  so as getParentNode,\n  co as getRectRelativeToOffsetParent,\n  ae as getUID,\n  ro as getWindow,\n  kn as hasAttribute,\n  Mn as hasAttributeNS,\n  zn as hasClass,\n  vn as isApple,\n  ie as isArray,\n  ao as isCanvas,\n  ue as isCustomElement,\n  R as isDocument,\n  io as isElement,\n  uo as isElementInScrollRange,\n  lo as isElementInViewport,\n  po as isElementsArray,\n  En as isFirefox,\n  mo as isFunction,\n  fo as isHTMLCollection,\n  u as isHTMLElement,\n  go as isHTMLImageElement,\n  vo as isJSON,\n  I as isMap,\n  bo as isMedia,\n  gn as isMobile,\n  i as isNode,\n  ho as isNodeList,\n  se as isNumber,\n  v as isObject,\n  yo as isRTL,\n  wo as isSVGElement,\n  re as isScaledElement,\n  ce as isShadowRoot,\n  k as isString,\n  Ao as isTableElement,\n  Eo as isWeakMap,\n  W as isWindow,\n  We as keyAlt,\n  Re as keyArrowDown,\n  je as keyArrowLeft,\n  qe as keyArrowRight,\n  Qe as keyArrowUp,\n  Ge as keyBackspace,\n  Je as keyCapsLock,\n  Ke as keyControl,\n  Xe as keyDelete,\n  Ye as keyEnter,\n  $e as keyEscape,\n  _e as keyInsert,\n  tn as keyMeta,\n  Ze as keyNumpadEnter,\n  en as keyPause,\n  nn as keyScrollLock,\n  on as keyShift,\n  sn as keySpace,\n  cn as keyTab,\n  Ue as keyboardEventKeys,\n  st as keydownEvent,\n  ct as keypressEvent,\n  rt as keyupEvent,\n  at as loadEvent,\n  xe as loadstartEvent,\n  Do as matches,\n  Be as mouseClickEvents,\n  He as mouseHoverEvents,\n  Ve as mouseSwipeEvents,\n  it as mouseclickEvent,\n  ut as mousedblclickEvent,\n  lt as mousedownEvent,\n  mt as mouseenterEvent,\n  pt as mousehoverEvent,\n  gt as mouseinEvent,\n  ft as mouseleaveEvent,\n  bt as mousemoveEvent,\n  vt as mouseoutEvent,\n  Et as mouseoverEvent,\n  dt as mouseupEvent,\n  ht as mousewheelEvent,\n  yt as moveEvent,\n  Te as nativeEvents,\n  Xt as noop,\n  jn as normalizeOptions,\n  V as normalizeValue,\n  Jt as off,\n  ln as offsetHeight,\n  dn as offsetWidth,\n  Gt as on,\n  Kt as one,\n  wt as orientationchangeEvent,\n  Yn as passiveHandler,\n  At as pointercancelEvent,\n  St as pointerdownEvent,\n  Nt as pointerleaveEvent,\n  kt as pointermoveEvent,\n  Mt as pointerupEvent,\n  So as querySelector,\n  Mo as querySelectorAll,\n  Tt as readystatechangeEvent,\n  Zn as reflow,\n  Cn as removeAttribute,\n  On as removeAttributeNS,\n  In as removeClass,\n  an as removeEventListener,\n  Dt as resetEvent,\n  Ct as resizeEvent,\n  zt as scrollEvent,\n  pn as scrollHeight,\n  mn as scrollWidth,\n  Ot as selectEvent,\n  Lt as selectendEvent,\n  It as selectstartEvent,\n  Tn as setAttribute,\n  Dn as setAttributeNS,\n  $n as setElementStyle,\n  xt as submitEvent,\n  bn as support3DTransform,\n  An as supportAnimation,\n  hn as supportPassive,\n  wn as supportTouch,\n  yn as supportTransform,\n  Sn as supportTransition,\n  fn as tabindex,\n  oe as toLowerCase,\n  to as toUpperCase,\n  Pe as touchEvents,\n  Ht as touchcancelEvent,\n  Pt as touchendEvent,\n  Bt as touchmoveEvent,\n  Vt as touchstartEvent,\n  Qt as transitionDelay,\n  Rt as transitionDuration,\n  C as transitionEndEvent,\n  U as transitionProperty,\n  Ft as unloadEvent,\n  S as userAgent,\n  A as userAgentData,\n  Co as version\n};\n//# sourceMappingURL=shorty.mjs.map\n","const e = {}, f = (t) => {\n  const { type: c, currentTarget: i } = t;\n  [...e[c]].forEach(([n, s]) => {\n    i === n && [...s].forEach(([o, a]) => {\n      o.apply(n, [t]), typeof a == \"object\" && a.once && r(n, c, o, a);\n    });\n  });\n}, E = (t, c, i, n) => {\n  e[c] || (e[c] = /* @__PURE__ */ new Map());\n  const s = e[c];\n  s.has(t) || s.set(t, /* @__PURE__ */ new Map());\n  const o = s.get(t), { size: a } = o;\n  o.set(i, n), a || t.addEventListener(c, f, n);\n}, r = (t, c, i, n) => {\n  const s = e[c], o = s && s.get(t), a = o && o.get(i), d = a !== void 0 ? a : n;\n  o && o.has(i) && o.delete(i), s && (!o || !o.size) && s.delete(t), (!s || !s.size) && delete e[c], (!o || !o.size) && t.removeEventListener(\n    c,\n    f,\n    d\n  );\n}, g = E, M = r;\nexport {\n  E as addListener,\n  f as globalListener,\n  M as off,\n  g as on,\n  e as registry,\n  r as removeListener\n};\n//# sourceMappingURL=event-listener.mjs.map\n","/**\n * Global namespace for most components `fade` class.\n */\nconst fadeClass = 'fade';\nexport default fadeClass;\n","/**\n * Global namespace for most components `show` class.\n */\nconst showClass = 'show';\nexport default showClass;\n","/**\n * Global namespace for most components `dismiss` option.\n */\nconst dataBsDismiss = 'data-bs-dismiss';\nexport default dataBsDismiss;\n","/** @type {string} */\nconst alertString = 'alert';\nexport default alertString;\n","/** @type {string} */\nconst alertComponent = 'Alert';\nexport default alertComponent;\n","import { version } from '../package.json';\n\nconst Version = version;\n\nexport default Version;\n","/* Native JavaScript for Bootstrap 5 | Base Component\n----------------------------------------------------- */\nimport { querySelector, normalizeOptions, Data, ObjectKeys, isString } from '@thednp/shorty';\n\nimport type { BaseOptions } from '../interface/baseComponent';\nimport Version from '../version';\n\n/** Returns a new `BaseComponent` instance. */\nexport default class BaseComponent {\n  declare element: HTMLElement;\n  declare options?: BaseOptions;\n\n  /**\n   * @param target `HTMLElement` or selector string\n   * @param config component instance options\n   */\n  constructor(target: HTMLElement | string, config?: BaseOptions) {\n    const element = querySelector(target);\n\n    if (!element) {\n      if (isString(target)) {\n        throw Error(`${this.name} Error: \"${target}\" is not a valid selector.`);\n      } else {\n        throw Error(`${this.name} Error: your target is not an instance of HTMLElement.`);\n      }\n    }\n\n    const prevInstance = Data.get<typeof this>(element, this.name);\n    /* istanbul ignore else */\n    if (prevInstance) {\n      // remove previously attached event listeners\n      // to avoid memory leaks\n      prevInstance._toggleEventListeners();\n    }\n\n    this.element = element;\n    this.options =\n      this.defaults && ObjectKeys(this.defaults).length\n        ? normalizeOptions(element, this.defaults, config || {}, 'bs')\n        : {};\n\n    Data.set(element, this.name, this);\n  }\n\n  /* istanbul ignore next */\n  get version() {\n    return Version;\n  }\n\n  /* istanbul ignore next */\n  get name() {\n    return 'BaseComponent';\n  }\n\n  /* istanbul ignore next */\n  get defaults() {\n    return {};\n  }\n\n  /** just to have something to extend from */\n  _toggleEventListeners = () => {\n    // do something to please linters\n  };\n\n  /** Removes component from target element. */\n  dispose() {\n    Data.remove<typeof this>(this.element, this.name);\n    ObjectKeys(this).forEach(prop => {\n      delete this[prop];\n    });\n  }\n}\n","/* Native JavaScript for Bootstrap 5 | Alert\n-------------------------------------------- */\nimport {\n  emulateTransitionEnd,\n  mouseclickEvent,\n  getInstance,\n  querySelector,\n  hasClass,\n  removeClass,\n  dispatchEvent,\n  createCustomEvent,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport fadeClass from '../strings/fadeClass';\nimport showClass from '../strings/showClass';\nimport dataBsDismiss from '../strings/dataBsDismiss';\nimport alertString from '../strings/alertString';\nimport alertComponent from '../strings/alertComponent';\nimport type { AlertEvent } from '../interface/alert';\n\nimport BaseComponent from './base-component';\n\n// ALERT PRIVATE GC\n// ================\nconst alertSelector = `.${alertString}`;\nconst alertDismissSelector = `[${dataBsDismiss}=\"${alertString}\"]`;\n\n/**\n * Static method which returns an existing `Alert` instance associated\n * to a target `Element`.\n *\n */\nconst getAlertInstance = (element: HTMLElement) => getInstance<Alert>(element, alertComponent);\n\n/**\n * An `Alert` initialization callback.\n */\nconst alertInitCallback = <T>(element: HTMLElement) => new Alert(element) as T;\n\n// ALERT CUSTOM EVENTS\n// ===================\nconst closeAlertEvent = createCustomEvent<AlertEvent>(`close.bs.${alertString}`);\nconst closedAlertEvent = createCustomEvent<AlertEvent>(`closed.bs.${alertString}`);\n\n// ALERT EVENT HANDLER\n// ===================\n/**\n * Alert `transitionend` callback.\n *\n * @param that target Alert instance\n */\nconst alertTransitionEnd = (self: Alert) => {\n  const { element } = self;\n  dispatchEvent(element, closedAlertEvent);\n\n  self._toggleEventListeners();\n  self.dispose();\n  element.remove();\n};\n\n// ALERT DEFINITION\n// ================\n/** Creates a new Alert instance. */\nexport default class Alert extends BaseComponent {\n  static selector = alertSelector;\n  static init = alertInitCallback;\n  static getInstance = getAlertInstance;\n  dismiss: HTMLElement | null;\n\n  constructor(target: HTMLElement | string) {\n    super(target);\n\n    // the dismiss button\n    this.dismiss = querySelector(alertDismissSelector, this.element);\n\n    // add event listener\n    this._toggleEventListeners(true);\n  }\n\n  /** Returns component name string. */\n  get name() {\n    return alertComponent;\n  }\n\n  // ALERT PUBLIC METHODS\n  // ====================\n  /**\n   * Public method that hides the `.alert` element from the user,\n   * disposes the instance once animation is complete, then\n   * removes the element from the DOM.\n   */\n  close = () => {\n    const { element } = this;\n\n    /* istanbul ignore else */\n    if (element && hasClass(element, showClass)) {\n      dispatchEvent(element, closeAlertEvent);\n\n      if (!closeAlertEvent.defaultPrevented) {\n        removeClass(element, showClass);\n\n        if (hasClass(element, fadeClass)) {\n          emulateTransitionEnd(element, () => alertTransitionEnd(this));\n        } else alertTransitionEnd(this);\n      }\n    }\n  };\n  /**\n   * Toggle on / off the `click` event listener.\n   *\n   * @param add when `true`, event listener is added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    const { dismiss, close } = this;\n    /* istanbul ignore else */\n    if (dismiss) action(dismiss, mouseclickEvent, close);\n  };\n\n  /** Remove the component from target element. */\n  dispose() {\n    this._toggleEventListeners();\n    super.dispose();\n  }\n}\n","/**\n * Global namespace for most components active class.\n */\nconst activeClass = 'active';\nexport default activeClass;\n","/**\n * Global namespace for most components `toggle` option.\n */\nconst dataBsToggle = 'data-bs-toggle';\nexport default dataBsToggle;\n","/** @type {string} */\nconst buttonString = 'button';\nexport default buttonString;\n","/** @type {string} */\nconst buttonComponent = 'Button';\nexport default buttonComponent;\n","/* Native JavaScript for Bootstrap 5 | Button\n---------------------------------------------*/\nimport {\n  getInstance,\n  removeClass,\n  hasClass,\n  addClass,\n  setAttribute,\n  mouseclickEvent,\n  ariaPressed,\n  getAttribute,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport activeClass from '../strings/activeClass';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport buttonString from '../strings/buttonString';\nimport buttonComponent from '../strings/buttonComponent';\n\nimport BaseComponent from './base-component';\n\n// BUTTON PRIVATE GC\n// =================\nconst buttonSelector = `[${dataBsToggle}=\"${buttonString}\"]`;\n\n/**\n * Static method which returns an existing `Button` instance associated\n * to a target `Element`.\n */\nconst getButtonInstance = (element: HTMLElement) => getInstance<Button>(element, buttonComponent);\n\n/** A `Button` initialization callback. */\nconst buttonInitCallback = (element: HTMLElement) => new Button(element);\n\n// BUTTON DEFINITION\n// =================\n/** Creates a new `Button` instance. */\nexport default class Button extends BaseComponent {\n  static selector = buttonSelector;\n  static init = buttonInitCallback;\n  static getInstance = getButtonInstance;\n\n  isActive = false;\n\n  /**\n   * @param target usually a `.btn` element\n   */\n  constructor(target: HTMLElement | string) {\n    super(target);\n\n    // initialization element\n    const { element } = this;\n\n    // set initial state\n    this.isActive = hasClass(element, activeClass);\n    setAttribute(element, ariaPressed, String(!!this.isActive));\n\n    // add event listener\n    this._toggleEventListeners(true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return buttonComponent;\n  }\n\n  // BUTTON PUBLIC METHODS\n  // =====================\n  /**\n   * Toggles the state of the target button.\n   *\n   * @param e usually `click` Event object\n   */\n  toggle = (e: Event) => {\n    if (e) e.preventDefault();\n\n    const { element, isActive } = this;\n    if (!hasClass(element, 'disabled') && !getAttribute(element, 'disabled')) {\n      const action = isActive ? removeClass : addClass;\n      action(element, activeClass);\n      setAttribute(element, ariaPressed, isActive ? 'false' : 'true');\n      this.isActive = hasClass(element, activeClass);\n    }\n  };\n\n  // BUTTON PRIVATE METHOD\n  // =====================\n  /**\n   * Toggles on/off the `click` event listener.\n   *\n   * @param add when `true`, event listener is added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    action(this.element, mouseclickEvent, this.toggle);\n  };\n\n  /** Removes the `Button` component from the target element. */\n  dispose() {\n    this._toggleEventListeners();\n    super.dispose();\n  }\n}\n","/**\n * Global namespace for most components `target` option.\n */\nconst dataBsTarget = 'data-bs-target';\nexport default dataBsTarget;\n","/** @type {string} */\nconst carouselString = 'carousel';\nexport default carouselString;\n","/** @type {string} */\nconst carouselComponent = 'Carousel';\nexport default carouselComponent;\n","/**\n * Global namespace for most components `parent` option.\n */\nconst dataBsParent = 'data-bs-parent';\nexport default dataBsParent;\n","/**\n * Global namespace for most components `container` option.\n */\nconst dataBsContainer = 'data-bs-container';\nexport default dataBsContainer;\n","import { getDocument, getAttribute, closest, querySelector } from '@thednp/shorty';\n\nimport dataBsTarget from '../strings/dataBsTarget';\nimport dataBsParent from '../strings/dataBsParent';\nimport dataBsContainer from '../strings/dataBsContainer';\n\n/**\n * Returns the `Element` that THIS one targets\n * via `data-bs-target`, `href`, `data-bs-parent` or `data-bs-container`.\n *\n * @param element the target element\n * @returns the query result\n */\nconst getTargetElement = (element: HTMLElement) => {\n  const targetAttr = [dataBsTarget, dataBsParent, dataBsContainer, 'href'];\n  const doc = getDocument(element);\n\n  return targetAttr\n    .map(att => {\n      const attValue = getAttribute(element, att);\n      if (attValue) {\n        return att === dataBsParent ? closest(element, attValue) : querySelector(attValue, doc);\n      }\n      return null;\n    })\n    .filter(x => x)[0];\n};\n\nexport default getTargetElement;\n","/* Native JavaScript for Bootstrap 5 | Carousel\n----------------------------------------------- */\nimport {\n  createCustomEvent,\n  getInstance,\n  dispatchEvent,\n  ObjectAssign,\n  emulateTransitionEnd,\n  passiveHandler,\n  reflow,\n  Timer,\n  getAttribute,\n  getElementsByClassName,\n  querySelectorAll,\n  querySelector,\n  closest,\n  isHTMLElement,\n  isRTL,\n  isElementInScrollRange,\n  getElementTransitionDuration,\n  getDocument,\n  pointerupEvent,\n  pointermoveEvent,\n  pointerdownEvent,\n  keyArrowRight,\n  keyArrowLeft,\n  keydownEvent,\n  mouseclickEvent,\n  mouseleaveEvent,\n  mouseenterEvent,\n  touchstartEvent,\n  dragstartEvent,\n  addClass,\n  hasClass,\n  removeClass,\n  matches,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport activeClass from '../strings/activeClass';\nimport dataBsTarget from '../strings/dataBsTarget';\nimport carouselString from '../strings/carouselString';\nimport carouselComponent from '../strings/carouselComponent';\nimport getTargetElement from '../util/getTargetElement';\nimport BaseComponent from './base-component';\nimport type { CarouselEvent, CarouselOptions } from '../interface/carousel';\n\n// CAROUSEL PRIVATE GC\n// ===================\nconst carouselSelector = `[data-bs-ride=\"${carouselString}\"]`;\nconst carouselItem = `${carouselString}-item`;\nconst dataBsSlideTo = 'data-bs-slide-to';\nconst dataBsSlide = 'data-bs-slide';\nconst pausedClass = 'paused';\n\nconst carouselDefaults: CarouselOptions = {\n  pause: 'hover',\n  keyboard: false,\n  touch: true,\n  interval: 5000,\n};\n\n/**\n * Static method which returns an existing `Carousel` instance associated\n * to a target `Element`.\n */\nconst getCarouselInstance = (element: HTMLElement) => getInstance<Carousel>(element, carouselComponent);\n\n/**\n * A `Carousel` initialization callback.\n */\nconst carouselInitCallback = (element: HTMLElement) => new Carousel(element);\n\nlet startX = 0;\nlet currentX = 0;\nlet endX = 0;\n\n// CAROUSEL CUSTOM EVENTS\n// ======================\nconst carouselSlideEvent = createCustomEvent<CarouselEvent>(`slide.bs.${carouselString}`);\nconst carouselSlidEvent = createCustomEvent<CarouselEvent>(`slid.bs.${carouselString}`);\n\n// CAROUSEL EVENT HANDLERS\n// =======================\n/**\n * The `transitionend` event listener of the `Carousel`.\n *\n * @param self the `Carousel` instance\n */\nconst carouselTransitionEndHandler = (self: Carousel) => {\n  const { index, direction, element, slides, options } = self;\n\n  /* istanbul ignore else */\n  if (self.isAnimating) {\n    const activeItem = getActiveIndex(self);\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    addClass(slides[index], activeClass);\n    removeClass(slides[index], `${carouselItem}-${orientation}`);\n    removeClass(slides[index], `${carouselItem}-${directionClass}`);\n\n    removeClass(slides[activeItem], activeClass);\n    removeClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n    dispatchEvent(element, carouselSlidEvent);\n    Timer.clear(element, dataBsSlide);\n\n    // must check if a previous instance is disposed\n    if (self.cycle && !getDocument(element).hidden && options.interval && !self.isPaused) {\n      self.cycle();\n    }\n  }\n};\n\n/**\n * Handles the `mouseenter` events when *options.pause*\n * is set to `hover`.\n */\nfunction carouselPauseHandler(this: HTMLElement) {\n  // const element = this;\n  const self = getCarouselInstance(this);\n  /* istanbul ignore else */\n  if (self && !self.isPaused && !Timer.get(this, pausedClass)) {\n    addClass(this, pausedClass);\n  }\n}\n\n/**\n * Handles the `mouseleave` events when *options.pause*\n * is set to `hover`.\n *\n */\nfunction carouselResumeHandler(this: HTMLElement) {\n  // const element = this;\n  const self = getCarouselInstance(this);\n  /* istanbul ignore else */\n  if (self && self.isPaused && !Timer.get(this, pausedClass)) {\n    self.cycle();\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` indicators.\n *\n * @param e the `Event` object\n */\nfunction carouselIndicatorHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  // const indicator = this;\n  const element = (closest(this, carouselSelector) || getTargetElement(this)) as HTMLElement;\n  const self = getCarouselInstance(element);\n\n  if (self && !self.isAnimating) {\n    const newIndex = +(getAttribute(this, dataBsSlideTo) || /* istanbul ignore next */ 0);\n\n    if (\n      this &&\n      !hasClass(this, activeClass) && // event target is not active\n      !Number.isNaN(newIndex)\n    ) {\n      // AND has the specific attribute\n      self.to(newIndex); // do the slide\n    }\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` arrows.\n *\n * @param e the `Event` object\n */\nfunction carouselControlsHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  const element = closest(this, carouselSelector) || (getTargetElement(this) as HTMLElement);\n  const self = getCarouselInstance(element);\n\n  if (self && !self.isAnimating) {\n    const orientation = getAttribute(this, dataBsSlide);\n\n    /* istanbul ignore else */\n    if (orientation === 'next') {\n      self.next();\n    } else if (orientation === 'prev') {\n      self.prev();\n    }\n  }\n}\n\n/**\n * Handles the keyboard `keydown` event for the visible `Carousel` elements.\n *\n * @param e the `Event` object\n */\nconst carouselKeyHandler = ({ code, target }: KeyboardEvent & { target: Node }) => {\n  const doc = getDocument(target);\n  const [element] = [...querySelectorAll(carouselSelector, doc)].filter(x => isElementInScrollRange(x));\n  const self = getCarouselInstance(element);\n\n  /* istanbul ignore next */\n  if (self && !self.isAnimating && !/textarea|input/i.test(target.nodeName)) {\n    const RTL = isRTL(element);\n    const arrowKeyNext = !RTL ? keyArrowRight : keyArrowLeft;\n    const arrowKeyPrev = !RTL ? keyArrowLeft : keyArrowRight;\n\n    /* istanbul ignore else */\n    if (code === arrowKeyPrev) self.prev();\n    else if (code === arrowKeyNext) self.next();\n  }\n};\n\n// CAROUSEL TOUCH HANDLERS\n// =======================\n/**\n * Prevents the `touchstart` and `dragstart` events for the `Carousel` element.\n *\n * @param e the `Event` object\n */\nfunction carouselDragHandler(this: HTMLElement, e: DragEvent | TouchEvent) {\n  const { target } = e;\n  const self = getCarouselInstance(this);\n\n  /* istanbul ignore next */\n  if (\n    self &&\n    self.isTouch &&\n    ((self.indicator && !self.indicator.contains(target as Node)) || !self.controls.includes(target as HTMLElement))\n  ) {\n    e.stopImmediatePropagation();\n    e.stopPropagation();\n    e.preventDefault();\n  }\n}\n\n// CAROUSEL POINTER HANDLERS\n// =========================\n/**\n * Handles the `pointerdown` event for the `Carousel` element.\n *\n * @param e the `Event` object\n */\nfunction carouselPointerDownHandler(this: HTMLElement, e: PointerEvent) {\n  const { target } = e;\n  const self = getCarouselInstance(this);\n\n  if (self && !self.isAnimating && !self.isTouch) {\n    // filter pointer event on controls & indicators\n    const { controls, indicators } = self;\n    if (![...controls, ...indicators].every(el => el === target || el.contains(target as Node))) {\n      startX = e.pageX;\n\n      /* istanbul ignore else */\n      if (this.contains(target as Node)) {\n        self.isTouch = true;\n        toggleCarouselTouchHandlers(self, true);\n      }\n    }\n  }\n}\n\n/**\n * Handles the `pointermove` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerMoveHandler = (e: PointerEvent) => {\n  currentX = e.pageX;\n};\n\n/**\n * Handles the `pointerup` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerUpHandler = (e: PointerEvent) => {\n  const { target } = e;\n  const doc = getDocument(target as Node);\n  const self = [...querySelectorAll(carouselSelector, doc)]\n    .map(c => getCarouselInstance(c) as Carousel)\n    .find(i => i.isTouch) as Carousel;\n\n  // impossible to satisfy\n  /* istanbul ignore else */\n  if (self) {\n    const { element, index } = self;\n    const RTL = isRTL(element);\n    endX = e.pageX;\n\n    self.isTouch = false;\n    toggleCarouselTouchHandlers(self);\n\n    if (\n      !doc.getSelection()?.toString().length &&\n      element.contains(target as HTMLElement) &&\n      Math.abs(startX - endX) > 120\n    ) {\n      // determine next index to slide to\n      /* istanbul ignore else */\n      if (currentX < startX) {\n        self.to(index + (RTL ? -1 : 1));\n      } else if (currentX > startX) {\n        self.to(index + (RTL ? 1 : -1));\n      }\n    }\n\n    // reset pointer position\n    startX = 0;\n    currentX = 0;\n    endX = 0;\n  }\n};\n\n// CAROUSEL PRIVATE METHODS\n// ========================\n/**\n * Sets active indicator for the `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param index the index of the new active indicator\n */\nconst activateCarouselIndicator = (self: Carousel, index: number) => {\n  const { indicators } = self;\n  [...indicators].forEach(x => removeClass(x, activeClass));\n\n  /* istanbul ignore else */\n  if (self.indicators[index]) addClass(indicators[index], activeClass);\n};\n\n/**\n * Toggles the pointer event listeners for a given `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param add when `TRUE` event listeners are added\n */\nconst toggleCarouselTouchHandlers = (self: Carousel, add?: boolean) => {\n  const { element } = self;\n  const action = add ? addListener : removeListener;\n  action(getDocument(element), pointermoveEvent, carouselPointerMoveHandler, passiveHandler);\n  action(getDocument(element), pointerupEvent, carouselPointerUpHandler, passiveHandler);\n};\n\n/**\n * Returns the index of the current active item.\n *\n * @param self the `Carousel` instance\n * @returns the query result\n */\nconst getActiveIndex = (self: Carousel) => {\n  const { slides, element } = self;\n  const activeItem = querySelector(`.${carouselItem}.${activeClass}`, element);\n  return isHTMLElement(activeItem) ? [...slides].indexOf(activeItem) : -1;\n};\n\n// CAROUSEL DEFINITION\n// ===================\n/** Creates a new `Carousel` instance. */\nexport default class Carousel extends BaseComponent {\n  static selector = carouselSelector;\n  static init = carouselInitCallback;\n  static getInstance = getCarouselInstance;\n  declare options: CarouselOptions;\n  declare direction: 'right' | 'left';\n  declare index: number;\n  declare isTouch: boolean;\n  declare slides: HTMLCollectionOf<HTMLElement>;\n  declare controls: HTMLElement[];\n  declare indicator: HTMLElement | null;\n  declare indicators: HTMLElement[];\n\n  /**\n   * @param target mostly a `.carousel` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<CarouselOptions>) {\n    super(target, config);\n\n    // initialization element\n    const { element } = this;\n\n    // additional properties\n    this.direction = isRTL(element) ? 'right' : 'left';\n    this.isTouch = false;\n\n    // carousel elements\n    // a LIVE collection is prefferable\n    this.slides = getElementsByClassName(carouselItem, element);\n    const { slides } = this;\n\n    // invalidate when not enough items\n    // no need to go further\n    if (slides.length >= 2) {\n      const activeIndex = getActiveIndex(this);\n      // recover item from disposed instance\n      const transitionItem = [...slides].find(s => matches(s, `.${carouselItem}-next,.${carouselItem}-next`));\n      this.index = activeIndex;\n\n      // external controls must be within same document context\n      const doc = getDocument(element);\n\n      this.controls = [\n        ...querySelectorAll(`[${dataBsSlide}]`, element),\n        ...querySelectorAll(`[${dataBsSlide}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n      ].filter((c, i, ar) => i === ar.indexOf(c));\n\n      this.indicator = querySelector(`.${carouselString}-indicators`, element);\n\n      // a LIVE collection is prefferable\n      this.indicators = [\n        ...(this.indicator ? querySelectorAll(`[${dataBsSlideTo}]`, this.indicator) : []),\n        ...querySelectorAll(`[${dataBsSlideTo}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n      ].filter((c, i, ar) => i === ar.indexOf(c));\n\n      // set JavaScript and DATA API options\n      const { options } = this;\n\n      // don't use TRUE as interval, it's actually 0, use the default 5000ms better\n      this.options.interval = options.interval === true ? carouselDefaults.interval : options.interval;\n\n      // set first slide active if none\n      /* istanbul ignore next - impossible to test with cypress */\n      if (transitionItem) {\n        this.index = [...slides].indexOf(transitionItem);\n      } else if (activeIndex < 0) {\n        this.index = 0;\n        addClass(slides[0], activeClass);\n        if (this.indicators.length) activateCarouselIndicator(this, 0);\n      }\n\n      /* istanbul ignore else */\n      if (this.indicators.length) activateCarouselIndicator(this, this.index);\n\n      // attach event handlers\n      this._toggleEventListeners(true);\n\n      // start to cycle if interval is set\n      if (options.interval) this.cycle();\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return carouselComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return carouselDefaults;\n  }\n\n  /**\n   * Check if instance is paused.\n   */\n  get isPaused() {\n    return hasClass(this.element, pausedClass);\n  }\n\n  /**\n   * Check if instance is animating.\n   */\n  get isAnimating() {\n    return querySelector(`.${carouselItem}-next,.${carouselItem}-prev`, this.element) !== null;\n  }\n\n  // CAROUSEL PUBLIC METHODS\n  // =======================\n  /** Slide automatically through items. */\n  cycle() {\n    const { element, options, isPaused, index } = this;\n\n    Timer.clear(element, carouselString);\n    if (isPaused) {\n      Timer.clear(element, pausedClass);\n      removeClass(element, pausedClass);\n    }\n\n    Timer.set(\n      element,\n      () => {\n        // it's very important to check self.element\n        // where instance might have been disposed\n        /* istanbul ignore else */\n        if (this.element && !this.isPaused && !this.isTouch && isElementInScrollRange(element)) {\n          this.to(index + 1);\n        }\n      },\n      options.interval as number,\n      carouselString,\n    );\n  }\n\n  /** Pause the automatic cycle. */\n  pause() {\n    const { element, options } = this;\n    /* istanbul ignore else */\n    if (!this.isPaused && options.interval) {\n      addClass(element, pausedClass);\n      Timer.set(\n        element,\n        () => {\n          /* ESLint is now happy */\n        },\n        1,\n        pausedClass,\n      );\n    }\n  }\n\n  /** Slide to the next item. */\n  next() {\n    /* istanbul ignore else */\n    if (!this.isAnimating) {\n      this.to(this.index + 1);\n    }\n  }\n\n  /** Slide to the previous item. */\n  prev() {\n    /* istanbul ignore else */\n    if (!this.isAnimating) {\n      this.to(this.index - 1);\n    }\n  }\n\n  /**\n   * Jump to the item with the `idx` index.\n   *\n   * @param idx the index of the item to jump to\n   */\n  to(idx: number) {\n    const { element, slides, options } = this;\n    const activeItem = getActiveIndex(this);\n    const RTL = isRTL(element);\n    let next = idx;\n\n    // when controled via methods, make sure to check again\n    // first return if we're on the same item #227\n    // `to()` must be SPAM protected by Timer\n    if (!this.isAnimating && activeItem !== next && !Timer.get(element, dataBsSlide)) {\n      // determine transition direction\n      /* istanbul ignore else */\n      if (activeItem < next || (activeItem === 0 && next === slides.length - 1)) {\n        this.direction = RTL ? 'right' : 'left'; // next\n      } else if (activeItem > next || (activeItem === slides.length - 1 && next === 0)) {\n        this.direction = RTL ? 'left' : 'right'; // prev\n      }\n      const { direction } = this;\n\n      // find the right next index\n      if (next < 0) {\n        next = slides.length - 1;\n      } else if (next >= slides.length) {\n        next = 0;\n      }\n\n      // orientation, class name, eventProperties\n      const orientation = direction === 'left' ? 'next' : 'prev';\n      const directionClass = direction === 'left' ? 'start' : 'end';\n\n      const eventProperties = {\n        relatedTarget: slides[next],\n        from: activeItem,\n        to: next,\n        direction,\n      };\n\n      // update event properties\n      ObjectAssign(carouselSlideEvent, eventProperties);\n      ObjectAssign(carouselSlidEvent, eventProperties);\n\n      // discontinue when prevented\n      dispatchEvent(element, carouselSlideEvent);\n      if (!carouselSlideEvent.defaultPrevented) {\n        // update index\n        this.index = next;\n        activateCarouselIndicator(this, next);\n\n        if (getElementTransitionDuration(slides[next]) && hasClass(element, 'slide')) {\n          Timer.set(\n            element,\n            () => {\n              addClass(slides[next], `${carouselItem}-${orientation}`);\n              reflow(slides[next]);\n              addClass(slides[next], `${carouselItem}-${directionClass}`);\n              addClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n              // the instance might get diposed mid-animation\n              emulateTransitionEnd(\n                slides[next],\n                () => this.slides && this.slides.length && carouselTransitionEndHandler(this),\n              );\n            },\n            0,\n            dataBsSlide,\n          );\n        } else {\n          addClass(slides[next], activeClass);\n          removeClass(slides[activeItem], activeClass);\n\n          Timer.set(\n            element,\n            () => {\n              Timer.clear(element, dataBsSlide);\n              // check for element, might have been disposed\n              /* istanbul ignore else */\n              if (element && options.interval && !this.isPaused) {\n                this.cycle();\n              }\n\n              dispatchEvent(element, carouselSlidEvent);\n            },\n            0,\n            dataBsSlide,\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Toggles all event listeners for the `Carousel` instance.\n   *\n   * @param add when `TRUE` event listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const { element, options, slides, controls, indicators } = this;\n    const { touch, pause, interval, keyboard } = options;\n    const action = add ? addListener : removeListener;\n\n    if (pause && interval) {\n      action(element, mouseenterEvent, carouselPauseHandler);\n      action(element, mouseleaveEvent, carouselResumeHandler);\n    }\n\n    if (touch && slides.length > 2) {\n      action(element, pointerdownEvent, carouselPointerDownHandler, passiveHandler);\n      action(element, touchstartEvent, carouselDragHandler, { passive: false });\n      action(element, dragstartEvent, carouselDragHandler, { passive: false });\n    }\n\n    /* istanbul ignore else */\n    if (controls.length) {\n      controls.forEach(arrow => {\n        /* istanbul ignore else */\n        if (arrow) action(arrow, mouseclickEvent, carouselControlsHandler);\n      });\n    }\n\n    /* istanbul ignore else */\n    if (indicators.length) {\n      indicators.forEach(indicator => {\n        action(indicator, mouseclickEvent, carouselIndicatorHandler);\n      });\n    }\n\n    if (keyboard) action(getDocument(element), keydownEvent, carouselKeyHandler);\n  };\n\n  /** Remove `Carousel` component from target. */\n  dispose() {\n    const { isAnimating } = this;\n\n    const clone = {\n      ...this,\n      isAnimating,\n    };\n    this._toggleEventListeners();\n    super.dispose();\n\n    // istanbul ignore next - impossible to test with cypress\n    if (clone.isAnimating) {\n      emulateTransitionEnd(clone.slides[clone.index], () => {\n        carouselTransitionEndHandler(clone);\n      });\n    }\n  }\n}\n","/**\n * Global namespace for most components `collapsing` class.\n * As used by `Collapse` / `Tab`.\n */\nconst collapsingClass = 'collapsing';\nexport default collapsingClass;\n","/** @type {string} */\nconst collapseString = 'collapse';\nexport default collapseString;\n","/** @type {string} */\nconst collapseComponent = 'Collapse';\nexport default collapseComponent;\n","/* Native JavaScript for Bootstrap 5 | Collapse\n----------------------------------------------- */\nimport {\n  getInstance,\n  setAttribute,\n  getDocument,\n  closest,\n  querySelector,\n  querySelectorAll,\n  addClass,\n  hasClass,\n  removeClass,\n  mouseclickEvent,\n  ariaExpanded,\n  emulateTransitionEnd,\n  reflow,\n  dispatchEvent,\n  setElementStyle,\n  Timer,\n  createCustomEvent,\n  noop,\n  isHTMLElement,\n  isString,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport dataBsToggle from '../strings/dataBsToggle';\nimport collapsingClass from '../strings/collapsingClass';\nimport showClass from '../strings/showClass';\nimport collapseString from '../strings/collapseString';\nimport collapseComponent from '../strings/collapseComponent';\n\nimport getTargetElement from '../util/getTargetElement';\nimport BaseComponent from './base-component';\nimport type { CollapseEvent, CollapseOptions } from '../interface/collapse';\n\n// COLLAPSE GC\n// ===========\nconst collapseSelector = `.${collapseString}`;\nconst collapseToggleSelector = `[${dataBsToggle}=\"${collapseString}\"]`;\nconst collapseDefaults = { parent: null };\n\n/**\n * Static method which returns an existing `Collapse` instance associated\n * to a target `Element`.\n */\nconst getCollapseInstance = (element: HTMLElement) => getInstance<Collapse>(element, collapseComponent);\n\n/**\n * A `Collapse` initialization callback.\n */\nconst collapseInitCallback = (element: HTMLElement) => new Collapse(element);\n\n// COLLAPSE CUSTOM EVENTS\n// ======================\nconst showCollapseEvent = createCustomEvent<CollapseEvent>(`show.bs.${collapseString}`);\nconst shownCollapseEvent = createCustomEvent<CollapseEvent>(`shown.bs.${collapseString}`);\nconst hideCollapseEvent = createCustomEvent<CollapseEvent>(`hide.bs.${collapseString}`);\nconst hiddenCollapseEvent = createCustomEvent<CollapseEvent>(`hidden.bs.${collapseString}`);\n\n// COLLAPSE PRIVATE METHODS\n// ========================\n/**\n * Expand the designated `Element`.\n *\n * @param self the `Collapse` instance\n */\nconst expandCollapse = (self: Collapse) => {\n  const { element, parent, triggers } = self;\n\n  dispatchEvent(element, showCollapseEvent);\n  if (!showCollapseEvent.defaultPrevented) {\n    Timer.set(element, noop, 17);\n    if (parent) Timer.set(parent, noop, 17);\n\n    addClass(element, collapsingClass);\n    removeClass(element, collapseString);\n\n    setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n    emulateTransitionEnd(element, () => {\n      Timer.clear(element);\n      if (parent) Timer.clear(parent);\n\n      triggers.forEach(btn => setAttribute(btn, ariaExpanded, 'true'));\n\n      removeClass(element, collapsingClass);\n      addClass(element, collapseString);\n      addClass(element, showClass);\n\n      setElementStyle(element, { height: '' });\n\n      dispatchEvent(element, shownCollapseEvent);\n    });\n  }\n};\n\n/**\n * Collapse the designated `Element`.\n *\n * @param self the `Collapse` instance\n */\nconst collapseContent = (self: Collapse) => {\n  const { element, parent, triggers } = self;\n\n  dispatchEvent(element, hideCollapseEvent);\n\n  if (!hideCollapseEvent.defaultPrevented) {\n    Timer.set(element, noop, 17);\n    if (parent) Timer.set(parent, noop, 17);\n\n    setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n    removeClass(element, collapseString);\n    removeClass(element, showClass);\n    addClass(element, collapsingClass);\n\n    reflow(element);\n    setElementStyle(element, { height: '0px' });\n\n    emulateTransitionEnd(element, () => {\n      Timer.clear(element);\n      /* istanbul ignore else */\n      if (parent) Timer.clear(parent);\n\n      triggers.forEach(btn => setAttribute(btn, ariaExpanded, 'false'));\n\n      removeClass(element, collapsingClass);\n      addClass(element, collapseString);\n\n      setElementStyle(element, { height: '' });\n\n      dispatchEvent(element, hiddenCollapseEvent);\n    });\n  }\n};\n\n// COLLAPSE EVENT HANDLER\n// ======================\n/**\n * Handles the `click` event for the `Collapse` instance.\n *\n * @param e the `Event` object\n */\nconst collapseClickHandler = (e: MouseEvent) => {\n  const { target } = e; // our target is `HTMLElement`\n  const trigger = target && closest(target as HTMLElement, collapseToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getCollapseInstance(element);\n  /* istanbul ignore else */\n  if (self) self.toggle();\n\n  // event target is anchor link #398\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n};\n\n// COLLAPSE DEFINITION\n// ===================\n\n/** Returns a new `Colapse` instance. */\nexport default class Collapse extends BaseComponent {\n  static selector = collapseSelector;\n  static init = collapseInitCallback;\n  static getInstance = getCollapseInstance;\n  declare options: CollapseOptions;\n  declare parent: HTMLElement | null;\n  declare triggers: HTMLElement[];\n\n  /**\n   * @param target and `Element` that matches the selector\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<CollapseOptions>) {\n    super(target, config);\n\n    // initialization element\n    const { element, options } = this;\n    const doc = getDocument(element);\n\n    // set triggering elements\n    this.triggers = [...querySelectorAll(collapseToggleSelector, doc)].filter(btn => getTargetElement(btn) === element);\n\n    // set parent accordion\n    this.parent = isHTMLElement(options.parent)\n      ? options.parent\n      : isString(options.parent)\n      ? getTargetElement(element) || querySelector(options.parent as string, doc)\n      : null;\n\n    // add event listeners\n    this._toggleEventListeners(true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return collapseComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return collapseDefaults;\n  }\n\n  // COLLAPSE PUBLIC METHODS\n  // =======================\n  /** Hides the collapse. */\n  hide() {\n    const { triggers, element } = this;\n    if (!Timer.get(element)) {\n      collapseContent(this);\n      /* istanbul ignore else */\n      if (triggers.length) {\n        triggers.forEach(btn => addClass(btn, `${collapseString}d`));\n      }\n    }\n  }\n\n  /** Shows the collapse. */\n  show() {\n    const { element, parent, triggers } = this;\n    let activeCollapse;\n    let activeCollapseInstance;\n\n    if (parent) {\n      activeCollapse = [...querySelectorAll(`.${collapseString}.${showClass}`, parent)].find(i =>\n        getCollapseInstance(i),\n      );\n      activeCollapseInstance = activeCollapse && getCollapseInstance(activeCollapse);\n    }\n\n    if ((!parent || !Timer.get(parent)) && !Timer.get(element)) {\n      if (activeCollapseInstance && activeCollapse !== element) {\n        collapseContent(activeCollapseInstance);\n        activeCollapseInstance.triggers.forEach(btn => {\n          addClass(btn, `${collapseString}d`);\n        });\n      }\n\n      expandCollapse(this);\n      /* istanbul ignore else */\n      if (triggers.length) {\n        triggers.forEach(btn => removeClass(btn, `${collapseString}d`));\n      }\n    }\n  }\n\n  /** Toggles the visibility of the collapse. */\n  toggle() {\n    if (!hasClass(this.element, showClass)) this.show();\n    else this.hide();\n  }\n\n  /**\n   * Toggles on/off the event listener(s) of the `Collapse` instance.\n   *\n   * @param add when `true`, the event listener is added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    const { triggers } = this;\n\n    /* istanbul ignore else */\n    if (triggers.length) {\n      triggers.forEach(btn => action(btn, mouseclickEvent, collapseClickHandler));\n    }\n  };\n\n  /** Remove the `Collapse` component from the target `Element`. */\n  dispose() {\n    this._toggleEventListeners();\n\n    super.dispose();\n  }\n}\n","/**\n * Global namespace for `Dropdown` types / classes.\n */\nconst dropdownMenuClasses = ['dropdown', 'dropup', 'dropstart', 'dropend'];\nexport default dropdownMenuClasses;\n","/** @type {string} */\nconst dropdownComponent = 'Dropdown';\nexport default dropdownComponent;\n","/**\n * Global namespace for `.dropdown-menu`.\n */\nconst dropdownMenuClass = 'dropdown-menu';\nexport default dropdownMenuClass;\n","import { hasAttribute, closest, getAttribute } from '@thednp/shorty';\n\n/**\n * Checks if an *event.target* or its parent has an `href=\"#\"` value.\n * We need to prevent jumping around onclick, don't we?\n *\n * @param element the target element\n * @returns the query result\n */\nconst isEmptyAnchor = (element: HTMLElement) => {\n  // `EventTarget` must be `HTMLElement`\n  const parentAnchor = closest(element, 'A');\n  return (\n    (element.tagName === 'A' &&\n      // anchor href starts with #\n      hasAttribute(element, 'href') &&\n      (getAttribute(element, 'href') as string).slice(-1) === '#') ||\n    // OR a child of an anchor with href starts with #\n    (parentAnchor &&\n      hasAttribute(parentAnchor, 'href') &&\n      (getAttribute(parentAnchor, 'href') as string).slice(-1) === '#')\n  );\n};\nexport default isEmptyAnchor;\n","/* Native JavaScript for Bootstrap 5 | Dropdown\n----------------------------------------------- */\nimport {\n  ariaExpanded,\n  focusEvent,\n  keydownEvent,\n  setAttribute,\n  keyEscape,\n  keyArrowDown,\n  keyArrowUp,\n  mouseclickEvent,\n  resizeEvent,\n  scrollEvent,\n  keyupEvent,\n  dispatchEvent,\n  setElementStyle,\n  getInstance,\n  ObjectAssign,\n  passiveHandler,\n  getElementsByClassName,\n  closest,\n  getAttribute,\n  getDocument,\n  getBoundingClientRect,\n  getDocumentElement,\n  getElementStyle,\n  isRTL,\n  removeClass,\n  hasClass,\n  addClass,\n  createCustomEvent,\n  focus,\n  getWindow,\n  CSS4Declaration,\n  isHTMLElement,\n  mousedownEvent,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport showClass from '../strings/showClass';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport dropdownClasses from '../strings/dropdownClasses';\nimport dropdownComponent from '../strings/dropdownComponent';\nimport dropdownMenuClass from '../strings/dropdownMenuClass';\n\nimport isEmptyAnchor from '../util/isEmptyAnchor';\nimport BaseComponent from './base-component';\nimport type { DropdownEvent, DropdownOptions } from '../interface/dropdown';\n\n// DROPDOWN PRIVATE GC\n// ===================\nconst [dropdownString, dropupString, dropstartString, dropendString] = dropdownClasses;\nconst dropdownSelector = `[${dataBsToggle}=\"${dropdownString}\"]`;\n\n/**\n * Static method which returns an existing `Dropdown` instance associated\n * to a target `Element`.\n */\nconst getDropdownInstance = (element: HTMLElement) => getInstance<Dropdown>(element, dropdownComponent);\n\n/**\n * A `Dropdown` initialization callback.\n */\nconst dropdownInitCallback = (element: HTMLElement) => new Dropdown(element);\n\n// DROPDOWN PRIVATE GC\n// ===================\n// const dropdownMenuStartClass = `${dropdownMenuClass}-start`;\nconst dropdownMenuEndClass = `${dropdownMenuClass}-end`;\nconst verticalClass = [dropdownString, dropupString];\nconst horizontalClass = [dropstartString, dropendString];\nconst menuFocusTags = ['A', 'BUTTON'];\n\nconst dropdownDefaults = {\n  offset: 5, // [number] 5(px)\n  display: 'dynamic', // [dynamic|static]\n};\n\n// DROPDOWN CUSTOM EVENTS\n// ======================\nconst showDropdownEvent = createCustomEvent<DropdownEvent>(`show.bs.${dropdownString}`);\nconst shownDropdownEvent = createCustomEvent<DropdownEvent>(`shown.bs.${dropdownString}`);\nconst hideDropdownEvent = createCustomEvent<DropdownEvent>(`hide.bs.${dropdownString}`);\nconst hiddenDropdownEvent = createCustomEvent<DropdownEvent>(`hidden.bs.${dropdownString}`);\nconst updatedDropdownEvent = createCustomEvent<DropdownEvent>(`updated.bs.${dropdownString}`);\n\n// DROPDOWN PRIVATE METHODS\n// ========================\n/**\n * Apply specific style or class names to a `.dropdown-menu` to automatically\n * accomodate the layout and the page scroll.\n *\n * @param self the `Dropdown` instance\n */\nconst styleDropdown = (self: Dropdown) => {\n  const { element, menu, parentElement, options } = self;\n  const { offset } = options;\n\n  // don't apply any style on mobile view\n  /* istanbul ignore else: this test requires a navbar */\n  if (getElementStyle(menu, 'position') !== 'static') {\n    const RTL = isRTL(element);\n    // const menuStart = hasClass(menu, dropdownMenuStartClass);\n    const menuEnd = hasClass(menu, dropdownMenuEndClass);\n\n    // reset menu offset and position\n    const resetProps = ['margin', 'top', 'bottom', 'left', 'right'];\n    resetProps.forEach(p => {\n      // menu.style[p] = '';\n      const style: { [key: string]: string } = {};\n      style[p] = '';\n      setElementStyle(menu, style);\n    });\n\n    // set initial position class\n    // take into account .btn-group parent as .dropdown\n    // this requires navbar/btn-group/input-group\n    let positionClass =\n      dropdownClasses.find(c => hasClass(parentElement, c)) ||\n      /* istanbul ignore next: fallback position */ dropdownString;\n\n    const dropdownMargin: { [key: string]: number[] } = {\n      dropdown: [offset, 0, 0],\n      dropup: [0, 0, offset],\n      dropstart: RTL ? [-1, 0, 0, offset] : [-1, offset, 0],\n      dropend: RTL ? [-1, offset, 0] : [-1, 0, 0, offset],\n    };\n\n    const dropdownPosition: { [key: string]: Partial<CSS4Declaration> } = {\n      dropdown: { top: '100%' },\n      dropup: { top: 'auto', bottom: '100%' },\n      dropstart: RTL ? { left: '100%', right: 'auto' } : { left: 'auto', right: '100%' },\n      dropend: RTL ? { left: 'auto', right: '100%' } : { left: '100%', right: 'auto' },\n      menuStart: RTL ? { right: '0', left: 'auto' } : { right: 'auto', left: '0' },\n      menuEnd: RTL ? { right: 'auto', left: '0' } : { right: '0', left: 'auto' },\n    };\n\n    const { offsetWidth: menuWidth, offsetHeight: menuHeight } = menu;\n\n    const { clientWidth, clientHeight } = getDocumentElement(element);\n    const {\n      left: targetLeft,\n      top: targetTop,\n      width: targetWidth,\n      height: targetHeight,\n    } = getBoundingClientRect(element);\n\n    // dropstart | dropend\n    const leftFullExceed = targetLeft - menuWidth - offset < 0;\n    // dropend\n    const rightFullExceed = targetLeft + menuWidth + targetWidth + offset >= clientWidth;\n    // dropstart | dropend\n    const bottomExceed = targetTop + menuHeight + offset >= clientHeight;\n    // dropdown\n    const bottomFullExceed = targetTop + menuHeight + targetHeight + offset >= clientHeight;\n    // dropup\n    const topExceed = targetTop - menuHeight - offset < 0;\n    // dropdown / dropup\n    const leftExceed = ((!RTL && menuEnd) || (RTL && !menuEnd)) && targetLeft + targetWidth - menuWidth < 0;\n    const rightExceed = ((RTL && menuEnd) || (!RTL && !menuEnd)) && targetLeft + menuWidth >= clientWidth;\n\n    // recompute position\n    // handle RTL as well\n    if (horizontalClass.includes(positionClass) && leftFullExceed && rightFullExceed) {\n      positionClass = dropdownString;\n    }\n    if (positionClass === dropstartString && (!RTL ? leftFullExceed : rightFullExceed)) {\n      positionClass = dropendString;\n    }\n    if (positionClass === dropendString && (RTL ? leftFullExceed : rightFullExceed)) {\n      positionClass = dropstartString;\n    }\n    if (positionClass === dropupString && topExceed && !bottomFullExceed) {\n      positionClass = dropdownString;\n    }\n    if (positionClass === dropdownString && bottomFullExceed && !topExceed) {\n      positionClass = dropupString;\n    }\n\n    // override position for horizontal classes\n    if (horizontalClass.includes(positionClass) && bottomExceed) {\n      ObjectAssign(dropdownPosition[positionClass], {\n        top: 'auto',\n        bottom: 0,\n      });\n    }\n\n    // override position for vertical classes\n    if (verticalClass.includes(positionClass) && (leftExceed || rightExceed)) {\n      // don't realign when menu is wider than window\n      // in both RTL and non-RTL readability is KING\n      let posAjust: { left: 'auto' | number; right: 'auto' | number } | undefined = { left: 'auto', right: 'auto' };\n      if (!leftExceed && rightExceed && !RTL) posAjust = { left: 'auto', right: 0 };\n      if (leftExceed && !rightExceed && RTL) posAjust = { left: 0, right: 'auto' };\n      if (posAjust) ObjectAssign(dropdownPosition[positionClass], posAjust);\n    }\n\n    const margins: number[] = dropdownMargin[positionClass];\n    setElementStyle(menu, {\n      ...dropdownPosition[positionClass],\n      margin: `${margins.map(x => (x ? `${x}px` : x)).join(' ')}`,\n    });\n\n    // override dropdown-menu-start | dropdown-menu-end\n    if (verticalClass.includes(positionClass) && menuEnd) {\n      /* istanbul ignore else */\n      if (menuEnd) {\n        const endAdjust =\n          (!RTL && leftExceed) || (RTL && rightExceed) ? 'menuStart' : /* istanbul ignore next */ 'menuEnd';\n        setElementStyle(menu, dropdownPosition[endAdjust]);\n      }\n    }\n    // trigger updated event\n    dispatchEvent(parentElement, updatedDropdownEvent);\n  }\n};\n\n/**\n * Returns an `Array` of focusable items in the given dropdown-menu.\n *\n * @param menu the target menu\n * @returns all children of the dropdown menu\n */\nconst getMenuItems = (menu: HTMLElement) => {\n  return [...menu.children]\n    .map(c => {\n      if (c && menuFocusTags.includes(c.tagName)) return c;\n      const { firstElementChild } = c;\n      if (firstElementChild && menuFocusTags.includes(firstElementChild.tagName)) {\n        return firstElementChild;\n      }\n      return null;\n    })\n    .filter(c => c);\n};\n\n/**\n * Toggles on/off the listeners for the events that close the dropdown\n * as well as event that request a new position for the dropdown.\n *\n * @param {Dropdown} self the `Dropdown` instance\n */\nconst toggleDropdownDismiss = (self: Dropdown) => {\n  const { element, options } = self;\n  const action = self.open ? addListener : removeListener;\n  const doc = getDocument(element);\n\n  action(doc, mouseclickEvent, dropdownDismissHandler);\n  action(doc, focusEvent, dropdownDismissHandler);\n  action(doc, keydownEvent, dropdownPreventScroll);\n  action(doc, keyupEvent, dropdownKeyHandler);\n\n  /* istanbul ignore else */\n  if (options.display === 'dynamic') {\n    [scrollEvent, resizeEvent].forEach(ev => {\n      action(getWindow(element), ev, dropdownLayoutHandler, passiveHandler);\n    });\n  }\n};\n\n/**\n * Returns the currently open `.dropdown` element.\n *\n * @param element target\n * @returns the query result\n */\nconst getCurrentOpenDropdown = (element: HTMLElement): HTMLElement | undefined => {\n  const currentParent = [...dropdownClasses, 'btn-group', 'input-group']\n    .map(c => getElementsByClassName(`${c} ${showClass}`, getDocument(element)))\n    .find(x => x.length);\n\n  if (currentParent && currentParent.length) {\n    return [...(currentParent[0].children as HTMLCollectionOf<HTMLElement>)].find(x =>\n      dropdownClasses.some(c => c === getAttribute(x, dataBsToggle)),\n    );\n  }\n  return undefined;\n};\n\n// DROPDOWN EVENT HANDLERS\n// =======================\n/**\n * Handles the `click` event for the `Dropdown` instance.\n *\n * @param e event object\n */\nconst dropdownDismissHandler = (e: MouseEvent) => {\n  const { target, type } = e;\n\n  /* istanbul ignore else */\n  if (target && isHTMLElement(target)) {\n    // some weird FF bug #409\n    const element = getCurrentOpenDropdown(target);\n    const self = element && getDropdownInstance(element);\n\n    /* istanbul ignore else */\n    if (self) {\n      const { parentElement, menu } = self;\n\n      const isForm =\n        parentElement &&\n        parentElement.contains(target) &&\n        (target.tagName === 'form' || closest(target, 'form') !== null);\n\n      if ([mouseclickEvent, mousedownEvent].includes(type) && isEmptyAnchor(target)) {\n        e.preventDefault();\n      }\n\n      /* istanbul ignore else */\n      if (!isForm && type !== focusEvent && target !== element && target !== menu) {\n        self.hide();\n      }\n    }\n  }\n};\n\n/**\n * Handles `click` event listener for `Dropdown`.\n *\n * @param e event object\n */\nconst dropdownClickHandler = (e: MouseEvent) => {\n  const { target } = e;\n  const element = target && closest(target as HTMLElement, dropdownSelector);\n  const self = element && getDropdownInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    e.stopPropagation();\n    self.toggle();\n    /* istanbul ignore else */\n    if (element && isEmptyAnchor(element)) e.preventDefault();\n  }\n};\n\n/**\n * Prevents scroll when dropdown-menu is visible.\n *\n * @param e event object\n */\nconst dropdownPreventScroll = (e: KeyboardEvent) => {\n  /* istanbul ignore else */\n  if ([keyArrowDown, keyArrowUp].includes(e.code)) e.preventDefault();\n};\n\n/**\n * Handles keyboard `keydown` events for `Dropdown`.\n *\n * @param e keyboard key\n */\nfunction dropdownKeyHandler(this: HTMLElement, e: KeyboardEvent) {\n  const { code } = e;\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n  const { activeElement } = (element && getDocument(element)) as Document;\n\n  /* istanbul ignore else */\n  if (self && activeElement) {\n    const { menu, open } = self;\n    const menuItems = getMenuItems(menu);\n\n    // arrow up & down\n    if (menuItems && menuItems.length && [keyArrowDown, keyArrowUp].includes(code)) {\n      let idx = menuItems.indexOf(activeElement);\n      /* istanbul ignore else */\n      if (activeElement === element) {\n        idx = 0;\n      } else if (code === keyArrowUp) {\n        idx = idx > 1 ? idx - 1 : 0;\n      } else if (code === keyArrowDown) {\n        idx = idx < menuItems.length - 1 ? idx + 1 : idx;\n      }\n      /* istanbul ignore else */\n      if (menuItems[idx]) focus(menuItems[idx] as HTMLElement);\n    }\n\n    if (keyEscape === code && open) {\n      self.toggle();\n      focus(element);\n    }\n  }\n}\n\n/** Handles dropdown layout changes during resize / scroll. */\nfunction dropdownLayoutHandler(this: HTMLElement) {\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n\n  /* istanbul ignore else */\n  if (self && self.open) styleDropdown(self);\n}\n\n// DROPDOWN DEFINITION\n// ===================\n/** Returns a new Dropdown instance. */\nexport default class Dropdown extends BaseComponent {\n  static selector = dropdownSelector;\n  static init = dropdownInitCallback;\n  static getInstance = getDropdownInstance;\n  declare options: DropdownOptions;\n  declare open: boolean;\n  declare parentElement: HTMLElement;\n  declare menu: HTMLElement;\n\n  /**\n   * @param target Element or string selector\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<DropdownOptions>) {\n    super(target, config);\n\n    // initialization element\n    const { parentElement } = this.element;\n    const [menu] = getElementsByClassName(dropdownMenuClass, parentElement as ParentNode);\n\n    // invalidate when dropdown-menu is missing\n    if (menu) {\n      // set targets\n      this.parentElement = parentElement as HTMLElement;\n      this.menu = menu;\n\n      // add event listener\n      this._toggleEventListeners(true);\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return dropdownComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return dropdownDefaults;\n  }\n\n  // DROPDOWN PUBLIC METHODS\n  // =======================\n  /** Shows/hides the dropdown menu to the user. */\n  toggle() {\n    if (this.open) this.hide();\n    else this.show();\n  }\n\n  /** Shows the dropdown menu to the user. */\n  show() {\n    const { element, open, menu, parentElement } = this;\n\n    /* istanbul ignore else */\n    if (!open) {\n      const currentElement = getCurrentOpenDropdown(element);\n      const currentInstance = currentElement && getDropdownInstance(currentElement);\n      if (currentInstance) currentInstance.hide();\n\n      // dispatch event\n      [showDropdownEvent, shownDropdownEvent, updatedDropdownEvent].forEach(e => {\n        e.relatedTarget = element;\n      });\n\n      dispatchEvent(parentElement, showDropdownEvent);\n      if (!showDropdownEvent.defaultPrevented) {\n        addClass(menu, showClass);\n        addClass(parentElement, showClass);\n        setAttribute(element, ariaExpanded, 'true');\n\n        // change menu position\n        styleDropdown(this);\n\n        this.open = !open;\n\n        focus(element); // focus the element\n        toggleDropdownDismiss(this);\n        dispatchEvent(parentElement, shownDropdownEvent);\n      }\n    }\n  }\n\n  /** Hides the dropdown menu from the user. */\n  hide() {\n    const { element, open, menu, parentElement } = this;\n\n    /* istanbul ignore else */\n    if (open) {\n      [hideDropdownEvent, hiddenDropdownEvent].forEach(e => {\n        e.relatedTarget = element;\n      });\n\n      dispatchEvent(parentElement, hideDropdownEvent);\n      if (!hideDropdownEvent.defaultPrevented) {\n        removeClass(menu, showClass);\n        removeClass(parentElement, showClass);\n        setAttribute(element, ariaExpanded, 'false');\n\n        this.open = !open;\n        // only re-attach handler if the instance is not disposed\n        toggleDropdownDismiss(this);\n        dispatchEvent(parentElement, hiddenDropdownEvent);\n      }\n    }\n  }\n\n  /**\n   * Toggles on/off the `click` event listener of the `Dropdown`.\n   *\n   * @param add when `true`, it will add the event listener\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    action(this.element, mouseclickEvent, dropdownClickHandler);\n  };\n\n  /** Removes the `Dropdown` component from the target element. */\n  dispose() {\n    if (this.open) this.hide();\n\n    this._toggleEventListeners();\n    super.dispose();\n  }\n}\n","/** @type {string} */\nconst modalString = 'modal';\nexport default modalString;\n","/** @type {string} */\nconst modalComponent = 'Modal';\nexport default modalComponent;\n","/** @type {string} */\nconst offcanvasComponent = 'Offcanvas';\nexport default offcanvasComponent;\n","/**\n * Global namespace for components `fixed-top` class.\n */\nconst fixedTopClass = 'fixed-top';\nexport default fixedTopClass;\n","/**\n * Global namespace for components `fixed-bottom` class.\n */\nconst fixedBottomClass = 'fixed-bottom';\nexport default fixedBottomClass;\n","/**\n * Global namespace for components `sticky-top` class.\n */\nconst stickyTopClass = 'sticky-top';\nexport default stickyTopClass;\n","/**\n * Global namespace for components `position-sticky` class.\n */\nconst positionStickyClass = 'position-sticky';\nexport default positionStickyClass;\n","import {\n  getWindow,\n  getDocumentElement,\n  getElementStyle,\n  getDocumentBody,\n  hasClass,\n  setElementStyle,\n  getElementsByClassName,\n} from '@thednp/shorty';\n\nimport fixedTopClass from '../strings/fixedTopClass';\nimport fixedBottomClass from '../strings/fixedBottomClass';\nimport stickyTopClass from '../strings/stickyTopClass';\nimport positionStickyClass from '../strings/positionStickyClass';\n\nconst getFixedItems = (parent?: ParentNode) => [\n  ...getElementsByClassName(fixedTopClass, parent),\n  ...getElementsByClassName(fixedBottomClass, parent),\n  ...getElementsByClassName(stickyTopClass, parent),\n  ...getElementsByClassName(positionStickyClass, parent),\n  ...getElementsByClassName('is-fixed', parent),\n];\n\n/**\n * Removes *padding* and *overflow* from the `<body>`\n * and all spacing from fixed items.\n *\n * @param element the target modal/offcanvas\n */\nexport const resetScrollbar = (element?: HTMLElement) => {\n  const bd = getDocumentBody(element);\n  setElementStyle(bd, {\n    paddingRight: '',\n    overflow: '',\n  });\n\n  const fixedItems = getFixedItems(bd);\n\n  if (fixedItems.length) {\n    fixedItems.forEach(fixed => {\n      setElementStyle(fixed, {\n        paddingRight: '',\n        marginRight: '',\n      });\n    });\n  }\n};\n\n/**\n * Returns the scrollbar width if the body does overflow\n * the window.\n *\n * @param element target element\n * @returns the scrollbar width value\n */\nexport const measureScrollbar = (element: HTMLElement) => {\n  const { clientWidth } = getDocumentElement(element);\n  const { innerWidth } = getWindow(element);\n  return Math.abs(innerWidth - clientWidth);\n};\n\n/**\n * Sets the `<body>` and fixed items style when modal / offcanvas\n * is shown to the user.\n *\n * @param element the target modal/offcanvas\n * @param overflow body does overflow or not\n */\nexport const setScrollbar = (element: HTMLElement, overflow?: boolean) => {\n  const bd = getDocumentBody(element);\n  const bodyPad = parseInt(getElementStyle(bd, 'paddingRight'), 10);\n  const isOpen = getElementStyle(bd, 'overflow') === 'hidden';\n  const sbWidth = isOpen && bodyPad ? 0 : measureScrollbar(element);\n  const fixedItems = getFixedItems(bd);\n\n  /* istanbul ignore else */\n  if (overflow) {\n    setElementStyle(bd, {\n      overflow: 'hidden',\n      paddingRight: `${bodyPad + sbWidth}px`,\n    });\n\n    /* istanbul ignore else */\n    if (fixedItems.length) {\n      fixedItems.forEach(fixed => {\n        const itemPadValue = getElementStyle(fixed, 'paddingRight');\n        fixed.style.paddingRight = `${parseInt(itemPadValue, 10) + sbWidth}px`;\n        /* istanbul ignore else */\n        if ([stickyTopClass, positionStickyClass].some(c => hasClass(fixed, c))) {\n          const itemMValue = getElementStyle(fixed, 'marginRight');\n          fixed.style.marginRight = `${parseInt(itemMValue, 10) - sbWidth}px`;\n        }\n      });\n    }\n  }\n};\n","/** @type {string} */\nconst offcanvasString = 'offcanvas';\nexport default offcanvasString;\n","import { getDocumentBody, isNode, createElement } from '@thednp/shorty';\n\n// the default container for Modal, Offcanvas, Popover and Tooltip\nconst popupContainer = createElement({ tagName: 'div', className: 'popup-container' }) as HTMLElement;\n\nconst appendPopup = (target: HTMLElement, customContainer?: ParentNode) => {\n  const containerIsBody = isNode(customContainer) && customContainer.nodeName === 'BODY';\n  const lookup = isNode(customContainer) && !containerIsBody ? customContainer : popupContainer;\n  const BODY = containerIsBody ? customContainer : getDocumentBody(target);\n\n  if (isNode(target)) {\n    if (lookup === popupContainer) {\n      BODY.append(popupContainer);\n    }\n    lookup.append(target);\n  }\n};\n\nconst removePopup = (target: HTMLElement, customContainer?: ParentNode) => {\n  const containerIsBody = isNode(customContainer) && customContainer.nodeName === 'BODY';\n  const lookup = isNode(customContainer) && !containerIsBody ? customContainer : popupContainer;\n\n  if (isNode(target)) {\n    target.remove();\n\n    if (lookup === popupContainer && !popupContainer.children.length) {\n      popupContainer.remove();\n    }\n  }\n};\n\nconst hasPopup = (target: HTMLElement, customContainer?: ParentNode) => {\n  const lookup = isNode(customContainer) && customContainer.nodeName !== 'BODY' ? customContainer : popupContainer;\n  return isNode(target) && lookup.contains(target);\n};\n\nexport { popupContainer, appendPopup, removePopup, hasPopup };\n","import {\n  createElement,\n  getDocument,\n  reflow,\n  removeClass,\n  hasClass,\n  addClass,\n  querySelector,\n  getDocumentBody,\n} from '@thednp/shorty';\n\nimport fadeClass from '../strings/fadeClass';\nimport showClass from '../strings/showClass';\nimport modalString from '../strings/modalString';\nimport offcanvasString from '../strings/offcanvasString';\nimport { resetScrollbar } from './scrollbar';\nimport { appendPopup, removePopup } from './popupContainer';\n\nconst backdropString = 'backdrop';\nconst modalBackdropClass = `${modalString}-${backdropString}`;\nconst offcanvasBackdropClass = `${offcanvasString}-${backdropString}`;\nconst modalActiveSelector = `.${modalString}.${showClass}`;\nconst offcanvasActiveSelector = `.${offcanvasString}.${showClass}`;\n\n// any document would suffice\nconst overlay = createElement('div') as HTMLElement;\n\n/**\n * Returns the current active modal / offcancas element.\n *\n * @param element the context element\n * @returns the requested element\n */\nconst getCurrentOpen = (element?: HTMLElement): HTMLElement | null => {\n  return querySelector(`${modalActiveSelector},${offcanvasActiveSelector}`, getDocument(element));\n};\n\n/**\n * Toogles from a Modal overlay to an Offcanvas, or vice-versa.\n *\n * @param isModal\n */\nconst toggleOverlayType = (isModal?: boolean) => {\n  const targetClass = isModal ? modalBackdropClass : offcanvasBackdropClass;\n  [modalBackdropClass, offcanvasBackdropClass].forEach(c => {\n    removeClass(overlay, c);\n  });\n  addClass(overlay, targetClass);\n};\n\n/**\n * Append the overlay to DOM.\n *\n * @param element\n * @param hasFade\n * @param isModal\n */\nconst appendOverlay = (element: HTMLElement, hasFade: boolean, isModal?: boolean) => {\n  toggleOverlayType(isModal);\n  appendPopup(overlay, getDocumentBody(element));\n  if (hasFade) addClass(overlay, fadeClass);\n};\n\n/**\n * Shows the overlay to the user.\n */\nconst showOverlay = () => {\n  if (!hasClass(overlay, showClass)) {\n    addClass(overlay, showClass);\n    reflow(overlay);\n  }\n};\n\n/**\n * Hides the overlay from the user.\n */\nconst hideOverlay = () => {\n  removeClass(overlay, showClass);\n};\n\n/**\n * Removes the overlay from DOM.\n *\n * @param element\n */\nconst removeOverlay = (element?: HTMLElement): void => {\n  if (!getCurrentOpen(element)) {\n    removeClass(overlay, fadeClass);\n    removePopup(overlay, getDocumentBody(element));\n    resetScrollbar(element);\n  }\n};\n\nexport {\n  overlay,\n  offcanvasBackdropClass,\n  modalBackdropClass,\n  modalActiveSelector,\n  offcanvasActiveSelector,\n  toggleOverlayType,\n  appendOverlay,\n  showOverlay,\n  hideOverlay,\n  getCurrentOpen,\n  removeOverlay,\n};\n","import { isHTMLElement, getElementStyle } from '@thednp/shorty';\n\n/**\n * @param element target\n * @returns the check result\n */\nconst isVisible = (element: HTMLElement) => {\n  return isHTMLElement(element) && getElementStyle(element, 'visibility') !== 'hidden' && element.offsetParent !== null;\n};\nexport default isVisible;\n","/* Native JavaScript for Bootstrap 5 | Modal\n-------------------------------------------- */\nimport {\n  keyEscape,\n  getElementTransitionDuration,\n  removeAttribute,\n  setAttribute,\n  keydownEvent,\n  mouseclickEvent,\n  resizeEvent,\n  ariaModal,\n  ariaHidden,\n  getInstance,\n  isRTL,\n  removeClass,\n  hasClass,\n  addClass,\n  closest,\n  querySelectorAll,\n  querySelector,\n  getDocumentElement,\n  getDocumentBody,\n  getDocument,\n  getWindow,\n  CSS4Declaration,\n  setElementStyle,\n  createCustomEvent,\n  emulateTransitionEnd,\n  passiveHandler,\n  dispatchEvent,\n  focus,\n  Timer,\n  MouseEvent,\n  KeyboardEvent,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport dataBsToggle from '../strings/dataBsToggle';\nimport dataBsDismiss from '../strings/dataBsDismiss';\nimport fadeClass from '../strings/fadeClass';\nimport showClass from '../strings/showClass';\nimport modalString from '../strings/modalString';\nimport modalComponent from '../strings/modalComponent';\nimport offcanvasComponent from '../strings/offcanvasComponent';\n\nimport getTargetElement from '../util/getTargetElement';\nimport { setScrollbar, measureScrollbar } from '../util/scrollbar';\nimport {\n  overlay,\n  modalActiveSelector,\n  toggleOverlayType,\n  appendOverlay,\n  showOverlay,\n  hideOverlay,\n  getCurrentOpen,\n  removeOverlay,\n} from '../util/backdrop';\nimport isVisible from '../util/isVisible';\nimport BaseComponent from './base-component';\nimport { ModalOptions, ModalEvent } from '../interface/modal';\nimport { hasPopup } from '../util/popupContainer';\n\n// MODAL PRIVATE GC\n// ================\nconst modalSelector = `.${modalString}`;\nconst modalToggleSelector = `[${dataBsToggle}=\"${modalString}\"]`;\nconst modalDismissSelector = `[${dataBsDismiss}=\"${modalString}\"]`;\nconst modalStaticClass = `${modalString}-static`;\n\nconst modalDefaults = {\n  backdrop: true,\n  keyboard: true,\n};\n\n/**\n * Static method which returns an existing `Modal` instance associated\n * to a target `Element`.\n */\nconst getModalInstance = (element: HTMLElement) => getInstance<Modal>(element, modalComponent);\n\n/**\n * A `Modal` initialization callback.\n */\nconst modalInitCallback = (element: HTMLElement) => new Modal(element);\n\n// MODAL CUSTOM EVENTS\n// ===================\nconst showModalEvent = createCustomEvent<ModalEvent>(`show.bs.${modalString}`);\nconst shownModalEvent = createCustomEvent<ModalEvent>(`shown.bs.${modalString}`);\nconst hideModalEvent = createCustomEvent<ModalEvent>(`hide.bs.${modalString}`);\nconst hiddenModalEvent = createCustomEvent<ModalEvent>(`hidden.bs.${modalString}`);\n\n// MODAL PRIVATE METHODS\n// =====================\n/**\n * Applies special style for the `<body>` and fixed elements\n * when a modal instance is shown to the user.\n *\n * @param self the `Modal` instance\n */\nconst setModalScrollbar = (self: Modal) => {\n  const { element } = self;\n  const scrollbarWidth = measureScrollbar(element);\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  const { clientHeight: modalHeight, scrollHeight: modalScrollHeight } = element;\n  const modalOverflow = modalHeight !== modalScrollHeight;\n\n  /* istanbul ignore else */\n  if (!modalOverflow && scrollbarWidth) {\n    const pad = !isRTL(element) ? 'paddingRight' : /* istanbul ignore next */ 'paddingLeft';\n    const padStyle = {} as Partial<CSS4Declaration>;\n    padStyle[pad] = `${scrollbarWidth}px`;\n    setElementStyle(element, padStyle);\n  }\n  setScrollbar(element, modalOverflow || clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the listeners of events that close the modal.\n *\n * @param self the `Modal` instance\n * @param add when `true`, event listeners are added\n */\nconst toggleModalDismiss = (self: Modal, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { element, update } = self;\n  action(element, mouseclickEvent, modalDismissHandler);\n  action(getWindow(element), resizeEvent, update, passiveHandler);\n  action(getDocument(element), keydownEvent, modalKeyHandler);\n};\n\n/**\n * Executes after a modal is hidden to the user.\n *\n * @param self the `Modal` instance\n */\nconst afterModalHide = (self: Modal) => {\n  const { triggers, element, relatedTarget } = self;\n  removeOverlay(element);\n  setElementStyle(element, { paddingRight: '', display: '' });\n  toggleModalDismiss(self);\n\n  const focusElement = showModalEvent.relatedTarget || triggers.find(isVisible);\n  /* istanbul ignore else */\n  if (focusElement) focus(focusElement as HTMLElement);\n\n  hiddenModalEvent.relatedTarget = relatedTarget as HTMLElement | undefined;\n  dispatchEvent(element, hiddenModalEvent);\n};\n\n/**\n * Executes after a modal is shown to the user.\n *\n * @param self the `Modal` instance\n */\nconst afterModalShow = (self: Modal) => {\n  const { element, relatedTarget } = self;\n  focus(element);\n  toggleModalDismiss(self, true);\n\n  shownModalEvent.relatedTarget = relatedTarget as HTMLElement | undefined;\n  dispatchEvent(element, shownModalEvent);\n};\n\n/**\n * Executes before a modal is shown to the user.\n *\n * @param self the `Modal` instance\n */\nconst beforeModalShow = (self: Modal) => {\n  const { element, hasFade } = self;\n  setElementStyle(element, { display: 'block' });\n  setModalScrollbar(self);\n  /* istanbul ignore else */\n  if (!getCurrentOpen(element)) {\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, showClass);\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n\n  if (hasFade) emulateTransitionEnd(element, () => afterModalShow(self));\n  else afterModalShow(self);\n};\n\n/**\n * Executes before a modal is hidden to the user.\n *\n * @param self the `Modal` instance\n */\nconst beforeModalHide = (self: Modal) => {\n  const { element, options, hasFade } = self;\n\n  // callback can also be the transitionEvent object, we wanna make sure it's not\n  // call is not forced and overlay is visible\n  if (options.backdrop && hasFade && hasClass(overlay, showClass) && !getCurrentOpen(element)) {\n    // AND no modal is visible\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => afterModalHide(self));\n  } else {\n    afterModalHide(self);\n  }\n};\n\n// MODAL EVENT HANDLERS\n// ====================\n/**\n * Handles the `click` event listener for modal.\n *\n * @param e the `Event` object\n */\nconst modalClickHandler = (e: MouseEvent<HTMLElement>) => {\n  const { target } = e;\n\n  const trigger = target && closest(target, modalToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getModalInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    /* istanbul ignore else */\n    if (trigger && trigger.tagName === 'A') e.preventDefault();\n    self.relatedTarget = trigger;\n    self.toggle();\n  }\n};\n\n/**\n * Handles the `keydown` event listener for modal\n * to hide the modal when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst modalKeyHandler = ({ code, target }: KeyboardEvent<HTMLElement>) => {\n  const element = querySelector(modalActiveSelector, getDocument(target));\n  const self = element && getModalInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    const { options } = self;\n    /* istanbul ignore else */\n    if (\n      options.keyboard &&\n      code === keyEscape && // the keyboard option is enabled and the key is 27\n      hasClass(element, showClass)\n    ) {\n      // the modal is not visible\n      self.relatedTarget = null;\n      self.hide();\n    }\n  }\n};\n\n/**\n * Handles the `click` event listeners that hide the modal.\n *\n * @param e the `Event` object\n */\nconst modalDismissHandler = (e: MouseEvent<HTMLElement>) => {\n  const { currentTarget } = e;\n  const self = currentTarget ? getModalInstance(currentTarget) : null;\n\n  // this timer is needed\n  /* istanbul ignore else: must have a filter */\n  if (self && currentTarget && !Timer.get(currentTarget)) {\n    const { options, isStatic, modalDialog } = self;\n    const { backdrop } = options;\n    const { target } = e;\n\n    const selectedText = getDocument(currentTarget)?.getSelection()?.toString().length;\n    const targetInsideDialog = modalDialog.contains(target);\n    const dismiss = target && closest(target, modalDismissSelector);\n\n    /* istanbul ignore else */\n    if (isStatic && !targetInsideDialog) {\n      Timer.set(\n        currentTarget,\n        () => {\n          addClass(currentTarget, modalStaticClass);\n          emulateTransitionEnd(modalDialog, () => staticTransitionEnd(self));\n        },\n        17,\n      );\n    } else if (dismiss || (!selectedText && !isStatic && !targetInsideDialog && backdrop)) {\n      self.relatedTarget = dismiss || null;\n      self.hide();\n      e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the `transitionend` event listeners for `Modal`.\n *\n * @param self the `Modal` instance\n */\nconst staticTransitionEnd = (self: Modal) => {\n  const { element, modalDialog } = self;\n  const duration = (getElementTransitionDuration(modalDialog) || 0) + 17;\n  removeClass(element, modalStaticClass);\n  // user must wait for zoom out transition\n  Timer.set(element, () => Timer.clear(element), duration);\n};\n\n// MODAL DEFINITION\n// ================\n/** Returns a new `Modal` instance. */\nexport default class Modal extends BaseComponent {\n  static selector = modalSelector;\n  static init = modalInitCallback;\n  static getInstance = getModalInstance;\n  declare options: ModalOptions;\n  declare modalDialog: HTMLElement;\n  declare triggers: HTMLElement[];\n  declare isStatic: boolean;\n  declare hasFade: boolean;\n  declare relatedTarget: HTMLElement | null;\n\n  /**\n   * @param target usually the `.modal` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<ModalOptions>) {\n    super(target, config);\n\n    // the modal\n    const { element } = this;\n\n    // the modal-dialog\n    const modalDialog = querySelector(`.${modalString}-dialog`, element);\n\n    /* istanbul ignore else */\n    if (modalDialog) {\n      this.modalDialog = modalDialog;\n      // modal can have multiple triggering elements\n      this.triggers = [...querySelectorAll(modalToggleSelector, getDocument(element))].filter(\n        btn => getTargetElement(btn) === element,\n      );\n\n      // additional internals\n      this.isStatic = this.options.backdrop === 'static';\n      this.hasFade = hasClass(element, fadeClass);\n      this.relatedTarget = null;\n\n      // attach event listeners\n      this._toggleEventListeners(true);\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return modalComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return modalDefaults;\n  }\n\n  // MODAL PUBLIC METHODS\n  // ====================\n  /** Toggles the visibility of the modal. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the modal to the user. */\n  show() {\n    const { element, options, hasFade, relatedTarget } = this;\n    const { backdrop } = options;\n    let overlayDelay = 0;\n\n    if (!hasClass(element, showClass)) {\n      showModalEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, showModalEvent);\n      if (!showModalEvent.defaultPrevented) {\n        // we elegantly hide any opened modal/offcanvas\n        const currentOpen = getCurrentOpen(element);\n\n        if (currentOpen && currentOpen !== element) {\n          const that =\n            getModalInstance(currentOpen) ||\n            /* istanbul ignore next */\n            getInstance<typeof BaseComponent & { hide: () => void }>(currentOpen, offcanvasComponent);\n          if (that) that.hide();\n        }\n        if (backdrop) {\n          if (!hasPopup(overlay)) {\n            appendOverlay(element, hasFade, true);\n          } else {\n            toggleOverlayType(true);\n          }\n\n          overlayDelay = getElementTransitionDuration(overlay);\n          showOverlay();\n\n          setTimeout(() => beforeModalShow(this), overlayDelay);\n        } else {\n          beforeModalShow(this);\n          /* istanbul ignore else */\n          if (currentOpen && hasClass(overlay, showClass)) {\n            hideOverlay();\n          }\n        }\n      }\n    }\n  }\n\n  /** Hide the modal from the user. */\n  hide() {\n    const { element, hasFade, relatedTarget } = this;\n\n    if (hasClass(element, showClass)) {\n      hideModalEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, hideModalEvent);\n\n      if (!hideModalEvent.defaultPrevented) {\n        removeClass(element, showClass);\n        setAttribute(element, ariaHidden, 'true');\n        removeAttribute(element, ariaModal);\n\n        /* istanbul ignore else */\n        if (hasFade) {\n          emulateTransitionEnd(element, () => beforeModalHide(this));\n        } else {\n          beforeModalHide(this);\n        }\n      }\n    }\n  }\n\n  /**\n   * Updates the modal layout.\n   */\n  update = () => {\n    /* istanbul ignore else */\n    if (hasClass(this.element, showClass)) setModalScrollbar(this);\n  };\n\n  /**\n   * Toggles on/off the `click` event listener of the `Modal` instance.\n   *\n   * @param add when `true`, event listener(s) is/are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    const { triggers } = this;\n\n    /* istanbul ignore else */\n    if (triggers.length) {\n      triggers.forEach(btn => action(btn, mouseclickEvent, modalClickHandler));\n    }\n  };\n\n  /** Removes the `Modal` component from target element. */\n  dispose() {\n    const clone = { ...this };\n    const { element, modalDialog } = clone;\n    // const callback = () => setTimeout(() => super.dispose(), 17);\n    const callback = () => super.dispose();\n    this._toggleEventListeners();\n\n    this.hide();\n\n    /* istanbul ignore else */\n    if (hasClass(element, 'fade')) {\n      // use transitionend callback\n      emulateTransitionEnd(modalDialog, callback);\n    } else {\n      callback();\n    }\n  }\n}\n","/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\nimport {\n  ariaHidden,\n  addClass,\n  hasClass,\n  closest,\n  querySelectorAll,\n  querySelector,\n  removeAttribute,\n  setAttribute,\n  keyEscape,\n  keydownEvent,\n  mouseclickEvent,\n  ariaModal,\n  emulateTransitionEnd,\n  dispatchEvent,\n  getElementTransitionDuration,\n  getDocumentBody,\n  getDocumentElement,\n  getDocument,\n  removeClass,\n  setElementStyle,\n  createCustomEvent,\n  focus,\n  getInstance,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport dataBsDismiss from '../strings/dataBsDismiss';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport showClass from '../strings/showClass';\nimport offcanvasString from '../strings/offcanvasString';\nimport offcanvasComponent from '../strings/offcanvasComponent';\nimport modalComponent from '../strings/modalComponent';\n\nimport getTargetElement from '../util/getTargetElement';\nimport isVisible from '../util/isVisible';\nimport { setScrollbar } from '../util/scrollbar';\nimport { hasPopup } from '../util/popupContainer';\nimport {\n  overlay,\n  offcanvasActiveSelector,\n  toggleOverlayType,\n  appendOverlay,\n  showOverlay,\n  hideOverlay,\n  getCurrentOpen,\n  removeOverlay,\n} from '../util/backdrop';\nimport BaseComponent from './base-component';\nimport { OffcanvasOptions, OffcanvasEvent } from '../interface/offcanvas';\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n */\nconst getOffcanvasInstance = (element: HTMLElement) => getInstance<Offcanvas>(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n */\nconst offcanvasInitCallback = (element: HTMLElement) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param self the `Offcanvas` instance\n */\nconst setOffCanvasScrollbar = (self: Offcanvas) => {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param self the `Offcanvas` instance\n * @param add when *true* listeners are added\n */\nconst toggleOffCanvasDismiss = (self: Offcanvas, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n};\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasShow = (self: Offcanvas) => {\n  const { element, options } = self;\n\n  /* istanbul ignore else */\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: 'visible' });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n};\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasHide = (self: Offcanvas) => {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  element.blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n  }\n  emulateTransitionEnd(element, () => hideOffcanvasComplete(self));\n};\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @param e the `Event` object\n */\nconst offcanvasTriggerHandler = (e: MouseEvent) => {\n  const trigger = closest(e.target as HTMLElement, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    self.relatedTarget = trigger;\n    self.toggle();\n    /* istanbul ignore else */\n    if (trigger && trigger.tagName === 'A') {\n      e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param e the `Event` object\n */\nconst offcanvasDismissHandler = (e: MouseEvent) => {\n  const { target } = e;\n  const element = querySelector(offcanvasActiveSelector, getDocument(target as Node));\n  const offCanvasDismiss = querySelector(offcanvasDismissSelector, element as HTMLElement | undefined);\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    const { options, triggers } = self;\n    const { backdrop } = options;\n    const trigger = closest(target as HTMLElement, offcanvasToggleSelector);\n    const selection = getDocument(element).getSelection();\n\n    /* istanbul ignore else: a filter is required here */\n    if (!overlay.contains(target as HTMLElement) || backdrop !== 'static') {\n      /* istanbul ignore else */\n      if (\n        !(selection && selection.toString().length) &&\n        ((!element.contains(target as HTMLElement) &&\n          backdrop &&\n          /* istanbul ignore next */ (!trigger || triggers.includes(target as HTMLElement))) ||\n          (offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement)))\n      ) {\n        self.relatedTarget =\n          offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement) ? offCanvasDismiss : null;\n        self.hide();\n      }\n\n      /* istanbul ignore next */\n      if (trigger && trigger.tagName === 'A') e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst offcanvasKeyDismissHandler = ({ code, target }: KeyboardEvent) => {\n  const element = querySelector(offcanvasActiveSelector, getDocument(target as Node));\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    /* istanbul ignore else */\n    if (self.options.keyboard && code === keyEscape) {\n      self.relatedTarget = null;\n      self.hide();\n    }\n  }\n};\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst showOffcanvasComplete = (self: Offcanvas) => {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n  setAttribute(element, 'role', 'dialog');\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n};\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst hideOffcanvasComplete = (self: Offcanvas) => {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, 'true');\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, 'role');\n  setElementStyle(element, { visibility: '' });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget || triggers.find(isVisible);\n  /* istanbul ignore else */\n  if (visibleTrigger) focus(visibleTrigger as HTMLElement);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n};\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nexport default class Offcanvas extends BaseComponent {\n  static selector = offcanvasSelector;\n  static init = offcanvasInitCallback;\n  static getInstance = getOffcanvasInstance;\n  declare options: OffcanvasOptions;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: HTMLElement | null;\n\n  /**\n   * @param target usually an `.offcanvas` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<OffcanvasOptions>) {\n    super(target, config);\n\n    // instance element\n    const { element } = this;\n\n    // all the triggering buttons\n    this.triggers = [...querySelectorAll(offcanvasToggleSelector, getDocument(element))].filter(\n      btn => getTargetElement(btn) === element,\n    );\n\n    // additional instance property\n    this.relatedTarget = null;\n\n    // attach event listeners\n    this._toggleEventListeners(true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return offcanvasComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return offcanvasDefaults;\n  }\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const { element, options, relatedTarget } = this;\n    let overlayDelay = 0;\n\n    if (!hasClass(element, showClass)) {\n      showOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      shownOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, showOffcanvasEvent);\n\n      if (!showOffcanvasEvent.defaultPrevented) {\n        // we elegantly hide any opened modal/offcanvas\n        const currentOpen = getCurrentOpen(element);\n        if (currentOpen && currentOpen !== element) {\n          const that =\n            getOffcanvasInstance(currentOpen) ||\n            /* istanbul ignore next */\n            getInstance<typeof BaseComponent & { hide: () => void }>(currentOpen, modalComponent);\n          if (that) that.hide();\n        }\n\n        if (options.backdrop) {\n          if (!hasPopup(overlay)) {\n            appendOverlay(element, true);\n          } else {\n            toggleOverlayType();\n          }\n\n          overlayDelay = getElementTransitionDuration(overlay);\n          showOverlay();\n\n          setTimeout(() => beforeOffcanvasShow(this), overlayDelay);\n        } else {\n          beforeOffcanvasShow(this);\n          /* istanbul ignore next - this test was done on Modal */\n          if (currentOpen && hasClass(overlay, showClass)) {\n            hideOverlay();\n          }\n        }\n      }\n    }\n  }\n\n  /** Hides the offcanvas from the user. */\n  hide() {\n    const { element, relatedTarget } = this;\n    // let overlayDelay = 0;\n\n    if (hasClass(element, showClass)) {\n      hideOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      hiddenOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, hideOffcanvasEvent);\n      if (!hideOffcanvasEvent.defaultPrevented) {\n        addClass(element, offcanvasTogglingClass);\n        removeClass(element, showClass);\n        beforeOffcanvasHide(this);\n      }\n    }\n  }\n\n  /**\n   * Toggles on/off the `click` event listeners.\n   *\n   * @param self the `Offcanvas` instance\n   * @param add when *true*, listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    this.triggers.forEach(btn => action(btn, mouseclickEvent, offcanvasTriggerHandler));\n  };\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const clone = { ...this };\n    const { element, options } = clone;\n    const delay = options.backdrop ? getElementTransitionDuration(overlay) : /* istanbul ignore next */ 0;\n    const callback = () => setTimeout(() => super.dispose(), delay + 17);\n    this._toggleEventListeners();\n\n    this.hide();\n    if (hasClass(element, showClass)) {\n      emulateTransitionEnd(element, callback);\n      /* istanbul ignore next */\n    } else {\n      callback();\n    }\n  }\n}\n","/** @type {string} */\nconst popoverString = 'popover';\nexport default popoverString;\n","/** @type {string} */\nconst popoverComponent = 'Popover';\nexport default popoverComponent;\n","/** @type {string} */\nconst tooltipString = 'tooltip';\nexport default tooltipString;\n","import tooltipString from '../strings/tooltipString';\n\n/**\n * Returns a template for Popover / Tooltip.\n *\n * @param tipType the expected markup type\n * @returns the template markup\n */\nconst getTipTemplate = (tipType: string) => {\n  const isTooltip = tipType === tooltipString;\n  const bodyClass = isTooltip ? `${tipType}-inner` : `${tipType}-body`;\n  const header = !isTooltip ? `<h3 class=\"${tipType}-header\"></h3>` : '';\n  const arrow = `<div class=\"${tipType}-arrow\"></div>`;\n  const body = `<div class=\"${bodyClass}\"></div>`;\n  return `<div class=\"${tipType}\" role=\"${tooltipString}\">${header + arrow + body}</div>`;\n};\n\nexport default getTipTemplate;\n","const tipClassPositions = {\n  top: 'top',\n  bottom: 'bottom',\n  left: 'start',\n  right: 'end',\n};\n\nexport default tipClassPositions;\n","import {\n  isHTMLElement,\n  setElementStyle,\n  getDocumentElement,\n  getBoundingClientRect,\n  getElementStyle,\n  isRTL,\n  toLowerCase,\n  createCustomEvent,\n  dispatchEvent,\n} from '@thednp/shorty';\n\nimport popoverComponent from '../strings/popoverComponent';\nimport tipClassPositions from './tipClassPositions';\nimport Tooltip from '../components/tooltip';\nimport type { TooltipEvent } from '../interface/tooltip';\nimport type { PopoverEvent } from '../interface/popover';\n\n/**\n * Style popovers and tooltips.\n *\n * @param self the `Popover` / `Tooltip` instance\n */\nconst styleTip = <T extends Tooltip>(self: T) => {\n  const tipClasses = /\\b(top|bottom|start|end)+/;\n  const { element, tooltip, container, options, arrow } = self;\n\n  /* istanbul ignore else */\n  if (tooltip) {\n    const tipPositions = { ...tipClassPositions };\n    const RTL = isRTL(element);\n\n    // reset tooltip style (top: 0, left: 0 works best)\n    setElementStyle(tooltip, {\n      // top: '0px', left: '0px', right: '', bottom: '',\n      top: '',\n      left: '',\n      right: '',\n      bottom: '',\n    });\n    const isPopover = self.name === popoverComponent;\n    const { offsetWidth: tipWidth, offsetHeight: tipHeight } = tooltip;\n    const { clientWidth: htmlcw, clientHeight: htmlch, offsetWidth: htmlow } = getDocumentElement(element);\n    let { placement } = options;\n    const { clientWidth: parentCWidth, offsetWidth: parentOWidth } = container as HTMLElement;\n    const parentPosition = getElementStyle(container as HTMLElement, 'position');\n    const fixedParent = parentPosition === 'fixed';\n    const scrollbarWidth = fixedParent ? Math.abs(parentCWidth - parentOWidth) : Math.abs(htmlcw - htmlow);\n    const leftBoundry = RTL && fixedParent ? /* istanbul ignore next */ scrollbarWidth : 0;\n    const rightBoundry = htmlcw - (!RTL ? scrollbarWidth : 0) - 1;\n    const {\n      width: elemWidth,\n      height: elemHeight,\n      left: elemRectLeft,\n      right: elemRectRight,\n      top: elemRectTop,\n    } = getBoundingClientRect(element, true);\n    const { x, y } = {\n      x: elemRectLeft,\n      y: elemRectTop,\n    };\n    // reset arrow style\n    setElementStyle(arrow as HTMLElement, {\n      top: '',\n      left: '',\n      right: '',\n      bottom: '',\n    });\n    let topPosition: number | string = 0;\n    let bottomPosition: number | string = '';\n    let leftPosition: number | string = 0;\n    let rightPosition: number | string = '';\n    let arrowTop: number | string = '';\n    let arrowLeft: number | string = '';\n    let arrowRight: number | string = '';\n\n    const arrowWidth = (arrow as HTMLElement).offsetWidth || 0;\n    const arrowHeight = (arrow as HTMLElement).offsetHeight || 0;\n    const arrowAdjust = arrowWidth / 2;\n\n    // check placement\n    let topExceed = elemRectTop - tipHeight - arrowHeight < 0;\n    let bottomExceed = elemRectTop + tipHeight + elemHeight + arrowHeight >= htmlch;\n    let leftExceed = elemRectLeft - tipWidth - arrowWidth < leftBoundry;\n    let rightExceed = elemRectLeft + tipWidth + elemWidth + arrowWidth >= rightBoundry;\n\n    const horizontals = ['left', 'right'];\n    const verticals = ['top', 'bottom'];\n\n    topExceed = horizontals.includes(placement)\n      ? elemRectTop + elemHeight / 2 - tipHeight / 2 - arrowHeight < 0\n      : topExceed;\n    bottomExceed = horizontals.includes(placement)\n      ? elemRectTop + tipHeight / 2 + elemHeight / 2 + arrowHeight >= htmlch\n      : bottomExceed;\n    leftExceed = verticals.includes(placement) ? elemRectLeft + elemWidth / 2 - tipWidth / 2 < leftBoundry : leftExceed;\n    rightExceed = verticals.includes(placement)\n      ? elemRectLeft + tipWidth / 2 + elemWidth / 2 >= rightBoundry\n      : rightExceed;\n\n    // first remove side positions if both left and right limits are exceeded\n    // we usually fall back to top|bottom\n    placement = horizontals.includes(placement) && leftExceed && rightExceed ? 'top' : placement;\n    // recompute placement\n    placement = placement === 'top' && topExceed ? 'bottom' : placement;\n    placement = placement === 'bottom' && bottomExceed ? 'top' : placement;\n    placement = placement === 'left' && leftExceed ? 'right' : placement;\n    placement = placement === 'right' && rightExceed ? /* istanbul ignore next */ 'left' : placement;\n\n    // update tooltip/popover class\n    if (!tooltip.className.includes(placement)) {\n      tooltip.className = tooltip.className.replace(tipClasses, tipPositions[placement]);\n    }\n\n    // compute tooltip / popover coordinates\n    /* istanbul ignore else */\n    if (horizontals.includes(placement)) {\n      // secondary|side positions\n      if (placement === 'left') {\n        // LEFT\n        leftPosition = x - tipWidth - (isPopover ? arrowWidth : 0);\n      } else {\n        // RIGHT\n        leftPosition = x + elemWidth + (isPopover ? arrowWidth : 0);\n      }\n\n      // adjust top and arrow\n      if (topExceed && bottomExceed) {\n        topPosition = 0;\n        bottomPosition = 0;\n        arrowTop = elemRectTop + elemHeight / 2 - arrowHeight / 2;\n      } else if (topExceed) {\n        topPosition = y;\n        bottomPosition = '';\n        arrowTop = elemHeight / 2 - arrowWidth;\n      } else if (bottomExceed) {\n        topPosition = y - tipHeight + elemHeight;\n        bottomPosition = '';\n        arrowTop = tipHeight - elemHeight / 2 - arrowWidth;\n      } else {\n        topPosition = y - tipHeight / 2 + elemHeight / 2;\n        arrowTop = tipHeight / 2 - arrowHeight / 2;\n      }\n    } else if (verticals.includes(placement)) {\n      if (placement === 'top') {\n        topPosition = y - tipHeight - (isPopover ? arrowHeight : 0);\n      } else {\n        // BOTTOM\n        topPosition = y + elemHeight + (isPopover ? arrowHeight : 0);\n      }\n\n      // adjust left | right and also the arrow\n      if (leftExceed) {\n        leftPosition = 0;\n        arrowLeft = x + elemWidth / 2 - arrowAdjust;\n      } else if (rightExceed) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = elemWidth / 2 + rightBoundry - elemRectRight - arrowAdjust;\n      } else {\n        leftPosition = x - tipWidth / 2 + elemWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    }\n\n    // apply style to tooltip/popover\n    setElementStyle(tooltip, {\n      top: `${topPosition}px`,\n      bottom: bottomPosition === '' ? '' : `${bottomPosition}px`,\n      left: leftPosition === 'auto' ? leftPosition : `${leftPosition}px`,\n      right: rightPosition !== '' ? `${rightPosition}px` : '',\n    });\n\n    // update arrow placement\n    /* istanbul ignore else */\n    if (isHTMLElement(arrow)) {\n      if (arrowTop !== '') {\n        arrow.style.top = `${arrowTop}px`;\n      }\n      if (arrowLeft !== '') {\n        arrow.style.left = `${arrowLeft}px`;\n      } else if (arrowRight !== '') {\n        arrow.style.right = `${arrowRight}px`;\n      }\n    }\n    const updatedTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`updated.bs.${toLowerCase(self.name)}`);\n    dispatchEvent(element, updatedTooltipEvent);\n  }\n};\n\nexport default styleTip;\n","import getTipTemplate from './getTipTemplate';\nimport tooltipString from '../strings/tooltipString';\nimport { TooltipOptions } from '../interface/tooltip';\n\nconst tooltipDefaults: TooltipOptions = {\n  template: getTipTemplate(tooltipString),\n  title: '',\n  customClass: '',\n  trigger: 'hover focus',\n  placement: 'top',\n  sanitizeFn: undefined,\n  animation: true,\n  delay: 200,\n  container: document.body,\n  content: '',\n  dismissible: false,\n  btnClose: '',\n};\nexport default tooltipDefaults;\n","/**\n * Global namespace for `data-bs-title` attribute.\n */\nconst dataOriginalTitle = 'data-original-title';\nexport default dataOriginalTitle;\n","/** @type {string} */\nconst tooltipComponent = 'Tooltip';\nexport default tooltipComponent;\n","import { isNode, isArray, isFunction, isString, isNodeList, isHTMLElement } from '@thednp/shorty';\n\n/**\n * Append an existing `Element` to Popover / Tooltip component or HTML\n * markup string to be parsed & sanitized to be used as popover / tooltip content.\n *\n * @param element target\n * @param content the `Element` to append / string\n * @param sanitizeFn a function to sanitize string content\n */\nconst setHtml = (element: HTMLElement, content: Node[] | Node | string, sanitizeFn?: (s: string) => string) => {\n  /* istanbul ignore else */\n  if (isString(content) && content.length) {\n    let dirty = content.trim(); // fixing #233\n    if (isFunction(sanitizeFn)) dirty = sanitizeFn(dirty);\n\n    const domParser = new DOMParser();\n    const tempDocument = domParser.parseFromString(dirty, 'text/html');\n    element.append(...[...tempDocument.body.childNodes]);\n  } else if (isHTMLElement(content)) {\n    element.append(content);\n  } else if (isNodeList(content) || (isArray(content) && content.every(isNode))) {\n    element.append(...[...content]);\n  }\n};\nexport default setHtml;\n","import { createElement, addClass, hasClass, setAttribute, querySelector, isRTL, isHTMLElement } from '@thednp/shorty';\n\nimport tooltipComponent from '../strings/tooltipComponent';\nimport tooltipString from '../strings/tooltipString';\nimport popoverString from '../strings/popoverString';\nimport fadeClass from '../strings/fadeClass';\nimport tipClassPositions from './tipClassPositions';\nimport setHtml from './setHtml';\nimport Tooltip from '../components/tooltip';\nimport Popover from '../components/popover';\n\n/**\n * Creates a new tooltip / popover.\n *\n * @param self the `Tooltip` / `Popover` instance\n */\nconst createTip = (self: Tooltip | Popover) => {\n  const isTooltip = self.name === tooltipComponent;\n\n  const { id, element, options } = self;\n  const { title, placement, template, animation, customClass, sanitizeFn, dismissible, content, btnClose } = options;\n  const tipString = isTooltip ? tooltipString : popoverString;\n  const tipPositions = { ...tipClassPositions };\n  let titleParts: Node[] = [];\n  let contentParts: Node[] = [];\n\n  if (isRTL(element)) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n\n  // set initial popover class\n  const placementClass = `bs-${tipString}-${tipPositions[placement]}`;\n\n  // load template\n  let tooltipTemplate: Node | string;\n  if (isHTMLElement(template)) {\n    tooltipTemplate = template;\n  } else {\n    const htmlMarkup = createElement('div') as HTMLElement;\n    setHtml(htmlMarkup, template, sanitizeFn);\n    tooltipTemplate = htmlMarkup.firstChild as HTMLElement;\n  }\n\n  // set popover markup\n  self.tooltip = isHTMLElement(tooltipTemplate)\n    ? (tooltipTemplate.cloneNode(true) as HTMLElement)\n    : /* istanbul ignore next */ undefined;\n\n  const { tooltip } = self;\n  /* istanbul ignore else */\n  if (tooltip) {\n    // set id and role attributes\n    setAttribute(tooltip, 'id', id);\n    setAttribute(tooltip, 'role', tooltipString);\n\n    const bodyClass = isTooltip ? `${tooltipString}-inner` : `${popoverString}-body`;\n    const tooltipHeader = isTooltip ? null : querySelector(`.${popoverString}-header`, tooltip);\n    const tooltipBody = querySelector(`.${bodyClass}`, tooltip);\n\n    // set arrow and enable access for styleTip\n    self.arrow = querySelector(`.${tipString}-arrow`, tooltip) as HTMLElement;\n    const { arrow } = self;\n\n    if (isHTMLElement(title)) titleParts = [title.cloneNode(true)];\n    else {\n      const tempTitle = createElement('div') as HTMLElement;\n      setHtml(tempTitle, title, sanitizeFn);\n      titleParts = [...[...tempTitle.childNodes]];\n    }\n\n    if (isHTMLElement(content)) contentParts = [content.cloneNode(true)];\n    else {\n      const tempContent = createElement('div') as HTMLElement;\n      setHtml(tempContent, content, sanitizeFn);\n      contentParts = [...[...tempContent.childNodes]];\n    }\n\n    // set dismissible button\n    if (dismissible) {\n      if (title) {\n        if (isHTMLElement(btnClose)) titleParts = [...titleParts, btnClose.cloneNode(true)];\n        else {\n          const tempBtn = createElement('div') as HTMLElement;\n          setHtml(tempBtn, btnClose, sanitizeFn);\n          titleParts = [...titleParts, tempBtn.firstChild as Node];\n        }\n      } else {\n        /* istanbul ignore else */\n        if (tooltipHeader) tooltipHeader.remove();\n        if (isHTMLElement(btnClose)) contentParts = [...contentParts, btnClose.cloneNode(true)];\n        else {\n          const tempBtn = createElement('div') as HTMLElement;\n          setHtml(tempBtn, btnClose, sanitizeFn);\n          contentParts = [...contentParts, tempBtn.firstChild as Node];\n        }\n      }\n    }\n\n    // fill the template with content from options / data attributes\n    // also sanitize title && content\n    /* istanbul ignore else */\n    if (!isTooltip) {\n      /* istanbul ignore else */\n      if (title && tooltipHeader) setHtml(tooltipHeader, titleParts, sanitizeFn);\n      /* istanbul ignore else */\n      if (content && tooltipBody) setHtml(tooltipBody, contentParts, sanitizeFn);\n      // set btn\n      self.btn = querySelector('.btn-close', tooltip) || undefined;\n    } else if (title && tooltipBody) setHtml(tooltipBody, title, sanitizeFn);\n\n    // Bootstrap 5.2.x\n    // addClass(tooltip, 'position-absolute');\n    addClass(tooltip, 'position-fixed');\n    addClass(arrow, 'position-absolute');\n\n    // set popover animation and placement\n    /* istanbul ignore else */\n    if (!hasClass(tooltip, tipString)) addClass(tooltip, tipString);\n    /* istanbul ignore else */\n    if (animation && !hasClass(tooltip, fadeClass)) addClass(tooltip, fadeClass);\n    /* istanbul ignore else */\n    if (customClass && !hasClass(tooltip, customClass)) {\n      addClass(tooltip, customClass);\n    }\n    /* istanbul ignore else */\n    if (!hasClass(tooltip, placementClass)) addClass(tooltip, placementClass);\n  }\n};\n\nexport default createTip;\n","import { getDocument, isShadowRoot, isTableElement, getParentNode, getElementStyle } from '@thednp/shorty';\n\n/**\n * Returns an `HTMLElement` to be used as default value for *options.container*\n * for `Tooltip` / `Popover` components.\n *\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param element the target\n * @returns the query result\n */\nconst getElementContainer = (element: HTMLElement): ParentNode => {\n  const majorBlockTags = ['HTML', 'BODY'];\n  const containers: ParentNode[] = [];\n  let { parentNode } = element as Node;\n\n  while (parentNode && !majorBlockTags.includes(parentNode.nodeName)) {\n    parentNode = getParentNode(parentNode) as ParentNode;\n    /* istanbul ignore else */\n    if (!(isShadowRoot(parentNode) || isTableElement(parentNode))) {\n      containers.push(parentNode);\n    }\n  }\n\n  return (\n    containers.find((c, i) => {\n      if (\n        getElementStyle(c as HTMLElement, 'position') !== 'relative' &&\n        containers.slice(i + 1).every(r => getElementStyle(r as HTMLElement, 'position') === 'static')\n      ) {\n        return c;\n      }\n      return null;\n    }) || /* istanbul ignore next: optional guard */ getDocument(element).body\n  );\n};\n\nexport default getElementContainer;\n","/* Native JavaScript for Bootstrap 5 | Tooltip\n---------------------------------------------- */\nimport {\n  ariaDescribedBy,\n  focusoutEvent,\n  focusinEvent,\n  focusEvent,\n  mouseleaveEvent,\n  mouseenterEvent,\n  mousedownEvent,\n  mouseclickEvent,\n  closest,\n  getUID,\n  getDocument,\n  getWindow,\n  removeAttribute,\n  getAttribute,\n  setAttribute,\n  hasAttribute,\n  touchstartEvent,\n  resizeEvent,\n  scrollEvent,\n  mousehoverEvent,\n  toLowerCase,\n  focus,\n  Timer,\n  emulateTransitionEnd,\n  passiveHandler,\n  dispatchEvent,\n  isApple,\n  getInstance,\n  ObjectAssign,\n  createCustomEvent,\n  removeClass,\n  hasClass,\n  addClass,\n  getElementStyle,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport dataBsToggle from '../strings/dataBsToggle';\nimport dataOriginalTitle from '../strings/dataOriginalTitle';\nimport showClass from '../strings/showClass';\nimport tooltipString from '../strings/tooltipString';\nimport tooltipComponent from '../strings/tooltipComponent';\nimport popoverString from '../strings/popoverString';\nimport popoverComponent from '../strings/popoverComponent';\nimport modalString from '../strings/modalString';\nimport offcanvasString from '../strings/offcanvasString';\n\nimport styleTip from '../util/styleTip';\nimport createTip from '../util/createTip';\nimport { appendPopup, removePopup, hasPopup } from '../util/popupContainer';\nimport getElementContainer from '../util/getElementContainer';\nimport tooltipDefaults from '../util/tooltipDefaults';\nimport BaseComponent from './base-component';\nimport { TooltipOptions, TooltipEvent } from '../interface/tooltip';\nimport { PopoverOptions, PopoverEvent } from '../interface/popover';\n\n// TOOLTIP PRIVATE GC\n// ==================\nconst tooltipSelector = `[${dataBsToggle}=\"${tooltipString}\"],[data-tip=\"${tooltipString}\"]`;\nconst titleAttr = 'title';\n\n/**\n * Static method which returns an existing `Tooltip` instance associated\n * to a target `Element`.\n *\n */\nlet getTooltipInstance = (element: HTMLElement) => getInstance<Tooltip>(element, tooltipComponent);\n\n/**\n * A `Tooltip` initialization callback.\n */\nconst tooltipInitCallback = (element: HTMLElement) => new Tooltip(element);\n\n// TOOLTIP PRIVATE METHODS\n// =======================\n/**\n * Removes the tooltip from the DOM.\n *\n * @param self the `Tooltip` instance\n */\nconst removeTooltip = (self: Tooltip) => {\n  const { element, tooltip, container, offsetParent } = self;\n  removeAttribute(element, ariaDescribedBy);\n  removePopup(tooltip as HTMLElement, container === offsetParent ? container : offsetParent);\n};\n\n/**\n * Check if container contains the tooltip.\n *\n * @param self Tooltip\n */\nconst hasTip = (self: Tooltip): boolean | undefined => {\n  const { tooltip, container, offsetParent } = self;\n\n  return tooltip && hasPopup(tooltip, container === offsetParent ? container : offsetParent);\n};\n\n/**\n * Executes after the instance has been disposed.\n *\n * @param self the `Tooltip` instance\n * @param callback the parent dispose callback\n */\nconst disposeTooltipComplete = (self: Tooltip, callback?: () => void) => {\n  const { element } = self;\n  self._toggleEventListeners();\n\n  /* istanbul ignore else */\n  if (hasAttribute(element, dataOriginalTitle) && self.name === tooltipComponent) {\n    toggleTooltipTitle(self);\n  }\n  /* istanbul ignore else */\n  if (callback) callback();\n};\n\n/**\n * Toggles on/off the special `Tooltip` event listeners.\n *\n * @param self the `Tooltip` instance\n * @param add when `true`, event listeners are added\n */\nconst toggleTooltipAction = (self: Tooltip, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n\n  action(getDocument(element), touchstartEvent, self.handleTouch, passiveHandler);\n\n  [scrollEvent, resizeEvent].forEach(ev => {\n    action(getWindow(element), ev, self.update, passiveHandler);\n  });\n};\n\n/**\n * Executes after the tooltip was shown to the user.\n *\n * @param self the `Tooltip` instance\n */\nconst tooltipShownAction = (self: Tooltip) => {\n  const { element } = self;\n  const shownTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`shown.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self, true);\n  dispatchEvent(element, shownTooltipEvent);\n  Timer.clear(element, 'in');\n};\n\n/**\n * Executes after the tooltip was hidden to the user.\n *\n * @param self the `Tooltip` instance\n */\nconst tooltipHiddenAction = (self: Tooltip) => {\n  const { element } = self;\n  const hiddenTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`hidden.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self);\n  removeTooltip(self);\n  dispatchEvent(element, hiddenTooltipEvent);\n\n  Timer.clear(element, 'out');\n};\n\n/**\n * Toggles on/off the `Tooltip` event listeners that hide/update the tooltip.\n *\n * @param self the `Tooltip` instance\n * @param add when `true`, event listeners are added\n */\nconst toggleTooltipOpenHandlers = (self: Tooltip, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { element, container, offsetParent } = self;\n  const { offsetHeight, scrollHeight } = container as HTMLElement;\n  const parentModal = closest(element, `.${modalString}`);\n  const parentOffcanvas = closest(element, `.${offcanvasString}`);\n\n  /* istanbul ignore else */\n  const win = getWindow(element);\n  const overflow = offsetHeight !== scrollHeight;\n  const scrollTarget = container === offsetParent && overflow ? container : win;\n  action(scrollTarget, resizeEvent, self.update, passiveHandler);\n  action(scrollTarget, scrollEvent, self.update, passiveHandler);\n\n  // dismiss tooltips inside modal / offcanvas\n  if (parentModal) action(parentModal, `hide.bs.${modalString}`, self.handleHide);\n  if (parentOffcanvas) action(parentOffcanvas, `hide.bs.${offcanvasString}`, self.handleHide);\n};\n\n/**\n * Toggles the `title` and `data-original-title` attributes.\n *\n * @param self the `Tooltip` instance\n * @param content when `true`, event listeners are added\n */\nconst toggleTooltipTitle = (self: Tooltip, content?: string) => {\n  // [0 - add, 1 - remove] | [0 - remove, 1 - add]\n  const titleAtt = [dataOriginalTitle, titleAttr];\n  const { element } = self;\n\n  setAttribute(\n    element,\n    titleAtt[content ? 0 : 1],\n    content || getAttribute(element, titleAtt[0]) || /* istanbul ignore next */ '',\n  );\n  removeAttribute(element, titleAtt[content ? 1 : 0]);\n};\n\n// TOOLTIP DEFINITION\n// ==================\n/** Creates a new `Tooltip` instance. */\nexport default class Tooltip extends BaseComponent {\n  static selector = tooltipSelector;\n  static init = tooltipInitCallback;\n  static getInstance = getTooltipInstance;\n  static styleTip = styleTip;\n  declare options: TooltipOptions;\n  declare btn?: HTMLElement;\n  declare tooltip?: HTMLElement;\n  declare container: ParentNode;\n  declare arrow?: HTMLElement;\n  declare offsetParent?: HTMLElement;\n  declare enabled: boolean;\n  declare id: string;\n\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<TooltipOptions>) {\n    super(target, config);\n\n    const { element } = this;\n    const isTooltip = this.name === tooltipComponent;\n    const tipString = isTooltip ? tooltipString : popoverString;\n    const tipComponent = isTooltip ? tooltipComponent : popoverComponent;\n\n    /* istanbul ignore next: this is to set Popover too */\n    getTooltipInstance = <T extends Tooltip>(elem: HTMLElement) => getInstance<T>(elem, tipComponent);\n\n    // additional properties\n    this.enabled = true;\n    /** Set unique ID for `aria-describedby`. */\n    this.id = `${tipString}-${getUID(element, tipString)}`;\n\n    // instance options\n    const { options } = this;\n\n    // invalidate\n    if (!((!options.title && isTooltip) || (!isTooltip && !options.content))) {\n      // reset default options\n      ObjectAssign(tooltipDefaults, { titleAttr: '' });\n\n      // set title attributes and add event listeners\n      /* istanbul ignore else */\n      if (hasAttribute(element, titleAttr) && isTooltip && typeof options.title === 'string') {\n        toggleTooltipTitle(this, options.title);\n      }\n\n      // set containers\n      this.container = getElementContainer(element);\n      this.offsetParent = ['sticky', 'fixed'].some(\n        position => getElementStyle(this.container as HTMLElement, 'position') === position,\n      )\n        ? (this.container as HTMLElement)\n        : getDocument(this.element).body;\n\n      // create tooltip here\n      createTip(this);\n\n      // attach events\n      this._toggleEventListeners(true);\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return tooltipComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return tooltipDefaults;\n  }\n\n  // TOOLTIP PUBLIC METHODS\n  // ======================\n  /** Handles the focus event on iOS. */\n  handleFocus = () => focus(this.element);\n  /** Shows the tooltip. */\n  handleShow = () => this.show();\n  show() {\n    const { options, tooltip, element, container, offsetParent, id } = this;\n    const { animation } = options;\n    const outTimer = Timer.get(element, 'out');\n    const tipContainer = container === offsetParent ? container : offsetParent;\n\n    Timer.clear(element, 'out');\n\n    if (tooltip && !outTimer && !hasTip(this)) {\n      Timer.set(\n        element,\n        () => {\n          const showTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`show.bs.${toLowerCase(this.name)}`);\n          dispatchEvent(element, showTooltipEvent);\n          if (!showTooltipEvent.defaultPrevented) {\n            // append to container\n            appendPopup(tooltip, tipContainer);\n\n            setAttribute(element, ariaDescribedBy, `#${id}`);\n\n            this.update();\n            toggleTooltipOpenHandlers(this, true);\n\n            /* istanbul ignore else */\n            if (!hasClass(tooltip, showClass)) addClass(tooltip, showClass);\n            /* istanbul ignore else */\n            if (animation) emulateTransitionEnd(tooltip, () => tooltipShownAction(this));\n            else tooltipShownAction(this);\n          }\n        },\n        17,\n        'in',\n      );\n    }\n  }\n\n  /** Hides the tooltip. */\n  handleHide = () => this.hide();\n  hide() {\n    const { options, tooltip, element } = this;\n    const { animation, delay } = options;\n\n    Timer.clear(element, 'in');\n\n    /* istanbul ignore else */\n    if (tooltip && hasTip(this)) {\n      Timer.set(\n        element,\n        () => {\n          const hideTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`hide.bs.${toLowerCase(this.name)}`);\n          dispatchEvent(element, hideTooltipEvent);\n\n          if (!hideTooltipEvent.defaultPrevented) {\n            this.update();\n            removeClass(tooltip, showClass);\n            toggleTooltipOpenHandlers(this);\n\n            /* istanbul ignore else */\n            if (animation) emulateTransitionEnd(tooltip, () => tooltipHiddenAction(this));\n            else tooltipHiddenAction(this);\n          }\n        },\n        delay + 17,\n        'out',\n      );\n    }\n  }\n\n  /** Updates the tooltip position. */\n  update = () => {\n    styleTip<Tooltip>(this);\n  };\n\n  /** Toggles the tooltip visibility. */\n  toggle = () => {\n    const { tooltip } = this;\n\n    if (tooltip && !hasTip(this)) this.show();\n    else this.hide();\n  };\n\n  /** Enables the tooltip. */\n  enable() {\n    const { enabled } = this;\n    /* istanbul ignore else */\n    if (!enabled) {\n      this._toggleEventListeners(true);\n      this.enabled = !enabled;\n    }\n  }\n\n  /** Disables the tooltip. */\n  disable() {\n    const { tooltip, options, enabled } = this;\n    const { animation } = options;\n    /* istanbul ignore else */\n    if (enabled) {\n      if (tooltip && hasTip(this) && animation) {\n        this.hide();\n        emulateTransitionEnd(tooltip, () => this._toggleEventListeners());\n      } else {\n        this._toggleEventListeners();\n      }\n      this.enabled = !enabled;\n    }\n  }\n\n  /** Toggles the `disabled` property. */\n  toggleEnabled() {\n    if (!this.enabled) this.enable();\n    else this.disable();\n  }\n\n  /**\n   * Handles the `touchstart` event listener for `Tooltip`\n   *\n   * @this {Tooltip}\n   * @param {TouchEvent} e the `Event` object\n   */\n  handleTouch = ({ target }: TouchEvent) => {\n    const { tooltip, element } = this;\n\n    /* istanbul ignore else */\n    if (\n      (tooltip && tooltip.contains(target as HTMLElement)) ||\n      target === element ||\n      (target && element.contains(target as HTMLElement))\n    ) {\n      // smile for ESLint\n    } else {\n      this.hide();\n    }\n  };\n\n  /**\n   * Toggles on/off the `Tooltip` event listeners.\n   *\n   * @param add when `true`, event listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    // btn is only for dismissible popover\n    const { element, options, btn } = this;\n    const { trigger } = options;\n    const isPopover = this.name !== tooltipComponent;\n    const dismissible = isPopover && (options as PopoverOptions).dismissible ? true : false;\n\n    /* istanbul ignore else */\n    if (!trigger.includes('manual')) {\n      this.enabled = !!add;\n\n      const triggerOptions = trigger.split(' ');\n\n      triggerOptions.forEach(tr => {\n        /* istanbul ignore else */\n        if (tr === mousehoverEvent) {\n          action(element, mousedownEvent, this.handleShow);\n          action(element, mouseenterEvent, this.handleShow);\n\n          /* istanbul ignore else */\n          if (!dismissible) {\n            action(element, mouseleaveEvent, this.handleHide);\n            action(getDocument(element), touchstartEvent, this.handleTouch, passiveHandler);\n          }\n        } else if (tr === mouseclickEvent) {\n          action(element, tr, !dismissible ? this.toggle : this.handleShow);\n        } else if (tr === focusEvent) {\n          action(element, focusinEvent, this.handleShow);\n          /* istanbul ignore else */\n          if (!dismissible) action(element, focusoutEvent, this.handleHide);\n          /* istanbul ignore else */\n          if (isApple) {\n            action(element, mouseclickEvent, this.handleFocus);\n          }\n        }\n        /* istanbul ignore else */\n        if (dismissible && btn) {\n          action(btn, mouseclickEvent, this.handleHide);\n        }\n      });\n    }\n  };\n\n  /** Removes the `Tooltip` from the target element. */\n  dispose() {\n    const { tooltip, options } = this;\n    const clone = { ...this, name: this.name };\n    const callback = () => setTimeout(() => disposeTooltipComplete(clone, () => super.dispose()), 17);\n\n    if (options.animation && hasTip(clone)) {\n      this.options.delay = 0; // reset delay\n      this.hide();\n      emulateTransitionEnd(tooltip as HTMLElement, callback);\n    } else {\n      callback();\n    }\n  }\n}\n","/* Native JavaScript for Bootstrap 5 | Popover\n---------------------------------------------- */\nimport { getInstance, ObjectAssign, focus } from '@thednp/shorty';\n\nimport dataBsToggle from '../strings/dataBsToggle';\nimport popoverString from '../strings/popoverString';\nimport popoverComponent from '../strings/popoverComponent';\n\nimport getTipTemplate from '../util/getTipTemplate';\nimport styleTip from '../util/styleTip';\nimport tooltipDefaults from '../util/tooltipDefaults';\nimport Tooltip from './tooltip';\n\nimport type { PopoverOptions /* , PopoverEvent */ } from '../interface/popover';\n\n// POPOVER PRIVATE GC\n// ==================\nconst popoverSelector = `[${dataBsToggle}=\"${popoverString}\"],[data-tip=\"${popoverString}\"]`;\n\nconst popoverDefaults: PopoverOptions = ObjectAssign({}, tooltipDefaults, {\n  template: getTipTemplate(popoverString),\n  content: '',\n  dismissible: false,\n  btnClose: '<button class=\"btn-close\" aria-label=\"Close\"></button>',\n});\n\n/**\n * Static method which returns an existing `Popover` instance associated\n * to a target `Element`.\n *\n */\nconst getPopoverInstance = (element: HTMLElement) => getInstance<Popover>(element, popoverComponent);\n\n/**\n * A `Popover` initialization callback.\n */\nconst popoverInitCallback = (element: HTMLElement) => new Popover(element);\n\n// POPOVER DEFINITION\n// ==================\n/** Returns a new `Popover` instance. */\nexport default class Popover extends Tooltip {\n  static selector = popoverSelector;\n  static init = popoverInitCallback;\n  static getInstance = getPopoverInstance;\n  static styleTip = styleTip;\n  declare options: PopoverOptions;\n\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<PopoverOptions>) {\n    super(target, config);\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return popoverComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return popoverDefaults;\n  }\n\n  /* extend original `show()` */\n  show = () => {\n    super.show();\n    // btn only exists within dismissible popover\n    const { options, btn } = this;\n    /* istanbul ignore else */\n    if (options.dismissible && btn) setTimeout(() => focus(btn), 17);\n  };\n}\n","/** @type {string} */\nconst scrollspyString = 'scrollspy';\nexport default scrollspyString;\n","/** @type {string} */\nconst scrollspyComponent = 'ScrollSpy';\nexport default scrollspyComponent;\n","/* Native JavaScript for Bootstrap 5 | ScrollSpy\n------------------------------------------------ */\nimport {\n  getDocumentBody,\n  getDocumentElement,\n  getDocument,\n  getWindow,\n  removeClass,\n  hasClass,\n  addClass,\n  getElementsByTagName,\n  getAttribute,\n  querySelector,\n  isHTMLElement,\n  isWindow,\n  createCustomEvent,\n  getInstance,\n  scrollEvent,\n  passiveHandler,\n  dispatchEvent,\n  getBoundingClientRect,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport activeClass from '../strings/activeClass';\nimport scrollspyString from '../strings/scrollspyString';\nimport scrollspyComponent from '../strings/scrollspyComponent';\n\nimport BaseComponent from './base-component';\nimport { ScrollSpyOptions, ScrollSpyEvent } from '../interface/scrollspy';\n\n// SCROLLSPY PRIVATE GC\n// ====================\nconst scrollspySelector = '[data-bs-spy=\"scroll\"]';\n\nconst scrollspyDefaults: ScrollSpyOptions = {\n  offset: 10,\n  target: null,\n};\n\n/**\n * Static method which returns an existing `ScrollSpy` instance associated\n * to a target `Element`.\n */\nconst getScrollSpyInstance = (element: HTMLElement) => getInstance<ScrollSpy>(element, scrollspyComponent);\n\n/**\n * A `ScrollSpy` initialization callback.\n */\nconst scrollspyInitCallback = (element: HTMLElement) => new ScrollSpy(element);\n\n// SCROLLSPY CUSTOM EVENT\n// ======================\nconst activateScrollSpy = createCustomEvent<ScrollSpyEvent>(`activate.bs.${scrollspyString}`);\n\n// SCROLLSPY PRIVATE METHODS\n// =========================\n/**\n * Update the state of all items.\n *\n * @param self the `ScrollSpy` instance\n */\nconst updateSpyTargets = (self: ScrollSpy) => {\n  const { target, scrollTarget, options, itemsLength, scrollHeight, element } = self;\n  const { offset } = options;\n  const isWin = isWindow(scrollTarget as Node | Window);\n\n  const links = target && getElementsByTagName('A', target);\n  const scrollHEIGHT = scrollTarget ? getScrollHeight(scrollTarget) : /* istanbul ignore next */ scrollHeight;\n\n  self.scrollTop = isWin ? (scrollTarget as Window).scrollY : (scrollTarget as HTMLElement).scrollTop;\n\n  // only update items/offsets once or with each mutation\n  /* istanbul ignore else */\n  if (links && (scrollHEIGHT !== scrollHeight || itemsLength !== links.length)) {\n    let href;\n    let targetItem;\n    let rect;\n\n    // reset arrays & update\n    self.items = [];\n    self.offsets = [];\n    self.scrollHeight = scrollHEIGHT;\n    self.maxScroll = self.scrollHeight - getOffsetHeight(self);\n\n    [...links].forEach(link => {\n      href = getAttribute(link, 'href');\n      targetItem =\n        href && href.charAt(0) === '#' && href.slice(-1) !== '#' && querySelector(href, getDocument(element));\n\n      if (targetItem) {\n        self.items.push(link);\n        rect = getBoundingClientRect(targetItem);\n        self.offsets.push((isWin ? rect.top + self.scrollTop : targetItem.offsetTop) - offset);\n      }\n    });\n    self.itemsLength = self.items.length;\n  }\n};\n\n/**\n * Returns the `scrollHeight` property of the scrolling element.\n *\n * @param scrollTarget the `ScrollSpy` instance\n * @return `scrollTarget` height\n */\nconst getScrollHeight = (scrollTarget: Node | Window) => {\n  return isHTMLElement(scrollTarget as Node)\n    ? (scrollTarget as HTMLElement).scrollHeight\n    : getDocumentElement(scrollTarget as Node).scrollHeight;\n};\n\n/**\n * Returns the height property of the scrolling element.\n *\n * @param params the `ScrollSpy` instance\n */\nconst getOffsetHeight = ({ element, scrollTarget }: ScrollSpy) => {\n  return isWindow(scrollTarget as Node) ? (scrollTarget as Window).innerHeight : getBoundingClientRect(element).height;\n};\n\n/**\n * Clear all items of the target.\n *\n * @param target a single item\n */\nconst clear = (target: HTMLElement) => {\n  [...getElementsByTagName('A', target)].forEach(item => {\n    if (hasClass(item, activeClass)) removeClass(item, activeClass);\n  });\n};\n\n/**\n * Activates a new item.\n *\n * @param self the `ScrollSpy` instance\n * @param item a single item\n */\nconst activate = (self: ScrollSpy, item: HTMLElement) => {\n  const { target, element } = self;\n  if (isHTMLElement(target)) clear(target);\n  self.activeItem = item;\n  addClass(item, activeClass);\n\n  // activate all parents\n  const parents: HTMLElement[] = [];\n  let parentItem = item;\n  while (parentItem !== getDocumentBody(element)) {\n    parentItem = parentItem.parentElement as HTMLElement;\n    if (hasClass(parentItem, 'nav') || hasClass(parentItem, 'dropdown-menu')) parents.push(parentItem);\n  }\n\n  parents.forEach(menuItem => {\n    const parentLink = menuItem.previousElementSibling as HTMLElement | null;\n\n    /* istanbul ignore else */\n    if (parentLink && !hasClass(parentLink, activeClass)) {\n      addClass(parentLink, activeClass);\n    }\n  });\n\n  // dispatch\n  activateScrollSpy.relatedTarget = item;\n  dispatchEvent(element, activateScrollSpy);\n};\n\n// SCROLLSPY DEFINITION\n// ====================\n/** Returns a new `ScrollSpy` instance. */\nexport default class ScrollSpy extends BaseComponent {\n  static selector = scrollspySelector;\n  static init = scrollspyInitCallback;\n  static getInstance = getScrollSpyInstance;\n  declare options: ScrollSpyOptions;\n  declare target: HTMLElement | null;\n  declare scrollTarget: HTMLElement | Window;\n  declare scrollTop: number;\n  declare maxScroll: number;\n  declare scrollHeight: number;\n  declare activeItem: HTMLElement | null;\n  declare items: HTMLElement[];\n  declare itemsLength: number;\n  declare offsets: number[];\n\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<ScrollSpyOptions>) {\n    super(target, config);\n\n    // initialization element & options\n    const { element, options } = this;\n\n    // additional properties\n    this.target = querySelector(options.target as HTMLElement | string, getDocument(element));\n\n    // invalidate\n    if (this.target) {\n      // set initial state\n      this.scrollTarget = element.clientHeight < element.scrollHeight ? element : getWindow(element);\n      this.scrollHeight = getScrollHeight(this.scrollTarget);\n\n      // add event handlers\n      this._toggleEventListeners(true);\n\n      this.refresh();\n    }\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return scrollspyComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return scrollspyDefaults;\n  }\n  /* eslint-enable */\n\n  // SCROLLSPY PUBLIC METHODS\n  // ========================\n  /** Updates all items. */\n  refresh = () => {\n    const { target } = this;\n\n    // check if target is visible and invalidate\n    /* istanbul ignore else */\n    if (isHTMLElement(target) && target.offsetHeight > 0) {\n      updateSpyTargets(this);\n\n      const { scrollTop, maxScroll, itemsLength, items, activeItem } = this;\n\n      if (scrollTop >= maxScroll) {\n        const newActiveItem = items[itemsLength - 1];\n\n        /* istanbul ignore else */\n        if (activeItem !== newActiveItem) {\n          activate(this, newActiveItem);\n        }\n        return;\n      }\n\n      const { offsets } = this;\n\n      if (activeItem && scrollTop < offsets[0] && offsets[0] > 0) {\n        this.activeItem = null;\n        if (target) clear(target);\n        return;\n      }\n\n      items.forEach((item, i) => {\n        if (\n          activeItem !== item &&\n          scrollTop >= offsets[i] &&\n          (typeof offsets[i + 1] === 'undefined' || scrollTop < offsets[i + 1])\n        ) {\n          activate(this, item);\n        }\n      });\n    }\n  };\n\n  /**\n   * Toggles on/off the component event listener.\n   *\n   * @param add when `true`, listener is added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    action(this.scrollTarget as EventTarget, scrollEvent, this.refresh, passiveHandler);\n  };\n\n  /** Removes `ScrollSpy` from the target element. */\n  dispose() {\n    this._toggleEventListeners();\n    super.dispose();\n  }\n}\n","/** @type {string} */\nconst tabString = 'tab';\nexport default tabString;\n","/** @type {string} */\nconst tabComponent = 'Tab';\nexport default tabComponent;\n","/* Native JavaScript for Bootstrap 5 | Tab\n------------------------------------------ */\nimport {\n  emulateTransitionEnd,\n  dispatchEvent,\n  removeClass,\n  hasClass,\n  addClass,\n  querySelector,\n  getElementsByClassName,\n  closest,\n  setAttribute,\n  mouseclickEvent,\n  createCustomEvent,\n  Timer,\n  getInstance,\n  ariaSelected,\n  reflow,\n  isHTMLElement,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport collapsingClass from '../strings/collapsingClass';\nimport activeClass from '../strings/activeClass';\nimport fadeClass from '../strings/fadeClass';\nimport showClass from '../strings/showClass';\nimport dropdownClasses from '../strings/dropdownClasses';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport tabString from '../strings/tabString';\nimport tabComponent from '../strings/tabComponent';\n\nimport getTargetElement from '../util/getTargetElement';\nimport BaseComponent from './base-component';\nimport type { /* TabOptions, */ TabEvent } from '../interface/tab';\n\n// TAB PRIVATE GC\n// ================\nconst tabSelector = `[${dataBsToggle}=\"${tabString}\"]`;\n\n/**\n * Static method which returns an existing `Tab` instance associated\n * to a target `Element`.\n */\nconst getTabInstance = (element: HTMLElement) => getInstance<Tab>(element, tabComponent);\n\n/** A `Tab` initialization callback. */\nconst tabInitCallback = (element: HTMLElement) => new Tab(element);\n\n// TAB CUSTOM EVENTS\n// =================\nconst showTabEvent = createCustomEvent<TabEvent>(`show.bs.${tabString}`);\nconst shownTabEvent = createCustomEvent<TabEvent>(`shown.bs.${tabString}`);\nconst hideTabEvent = createCustomEvent<TabEvent>(`hide.bs.${tabString}`);\nconst hiddenTabEvent = createCustomEvent<TabEvent>(`hidden.bs.${tabString}`);\n\ninterface TabPrivate {\n  tab: HTMLElement | null;\n  content: HTMLElement | null;\n  currentHeight: number;\n  nextHeight: number;\n}\n\n/**\n * Stores the current active tab and its content\n * for a given `.nav` element.\n */\nconst tabPrivate: Map<HTMLElement, TabPrivate> = new Map();\n\n// TAB PRIVATE METHODS\n// ===================\n/**\n * Executes after tab transition has finished.\n *\n * @param self the `Tab` instance\n */\nconst triggerTabEnd = (self: Tab) => {\n  const { tabContent, nav } = self;\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(tabContent, collapsingClass)) {\n    tabContent.style.height = '';\n    removeClass(tabContent, collapsingClass);\n  }\n\n  /* istanbul ignore else */\n  if (nav) Timer.clear(nav);\n};\n\n/**\n * Executes before showing the tab content.\n *\n * @param self the `Tab` instance\n */\nconst triggerTabShow = (self: Tab) => {\n  const { element, tabContent, content: nextContent, nav } = self;\n  const { tab } = (isHTMLElement(nav) && tabPrivate.get(nav)) || /* istanbul ignore next */ { tab: null };\n\n  /* istanbul ignore else */\n  if (tabContent && nextContent && hasClass(nextContent, fadeClass)) {\n    const { currentHeight, nextHeight } = tabPrivate.get(element) || /* istanbul ignore next */ {\n      currentHeight: 0,\n      nextHeight: 0,\n    };\n    if (currentHeight === nextHeight) {\n      triggerTabEnd(self);\n    } else {\n      // enables height animation\n      setTimeout(() => {\n        tabContent.style.height = `${nextHeight}px`;\n        reflow(tabContent);\n        emulateTransitionEnd(tabContent, () => triggerTabEnd(self));\n      }, 50);\n    }\n  } else if (nav) Timer.clear(nav);\n\n  shownTabEvent.relatedTarget = tab as HTMLElement | undefined;\n\n  dispatchEvent(element, shownTabEvent);\n};\n\n/**\n * Executes before hiding the tab.\n *\n * @param self the `Tab` instance\n */\nconst triggerTabHide = (self: Tab) => {\n  const { element, content: nextContent, tabContent, nav } = self;\n  const { tab, content } = (nav && tabPrivate.get(nav)) || /* istanbul ignore next */ { tab: null, content: null };\n  let currentHeight = 0;\n\n  /* istanbul ignore else */\n  if (tabContent && nextContent && hasClass(nextContent, fadeClass)) {\n    [content, nextContent].forEach(c => {\n      if (isHTMLElement(c)) addClass(c, 'overflow-hidden');\n    });\n    currentHeight = isHTMLElement(content) ? content.scrollHeight : /* istanbul ignore next */ 0;\n  }\n\n  // update relatedTarget and dispatch event\n  showTabEvent.relatedTarget = tab as HTMLElement | undefined;\n  hiddenTabEvent.relatedTarget = element;\n  dispatchEvent(element, showTabEvent);\n\n  if (!showTabEvent.defaultPrevented) {\n    if (nextContent) addClass(nextContent, activeClass);\n    if (content) removeClass(content, activeClass);\n\n    /* istanbul ignore else */\n    if (tabContent && nextContent && hasClass(nextContent, fadeClass)) {\n      const nextHeight = nextContent.scrollHeight;\n      tabPrivate.set(element, { currentHeight, nextHeight, tab: null, content: null });\n\n      addClass(tabContent, collapsingClass);\n      tabContent.style.height = `${currentHeight}px`;\n      reflow(tabContent);\n      [content, nextContent].forEach(c => {\n        if (c) removeClass(c, 'overflow-hidden');\n      });\n    }\n\n    if (nextContent && nextContent && hasClass(nextContent, fadeClass)) {\n      setTimeout(() => {\n        addClass(nextContent, showClass);\n        emulateTransitionEnd(nextContent, () => {\n          triggerTabShow(self);\n        });\n      }, 1);\n    } else {\n      if (nextContent) addClass(nextContent, showClass);\n      triggerTabShow(self);\n    }\n\n    if (tab) dispatchEvent(tab, hiddenTabEvent);\n  }\n};\n\n/**\n * Returns the current active tab and its target content.\n *\n * @param self the `Tab` instance\n * @returns the query result\n */\nconst getActiveTab = (self: Tab): { tab: HTMLElement | null; content: HTMLElement | null } => {\n  const { nav } = self;\n  /* istanbul ignore next */\n  if (!isHTMLElement(nav as HTMLElement | undefined)) return { tab: null, content: null };\n\n  const activeTabs = getElementsByClassName(activeClass, nav as HTMLElement);\n  let tab: HTMLElement | null = null;\n  /* istanbul ignore else */\n  if (activeTabs.length === 1 && !dropdownClasses.some(c => hasClass(activeTabs[0].parentElement as HTMLElement, c))) {\n    [tab] = activeTabs;\n  } else if (activeTabs.length > 1) {\n    tab = activeTabs[activeTabs.length - 1];\n  }\n  const content = isHTMLElement(tab as HTMLElement) ? getTargetElement(tab as HTMLElement) : null;\n  return { tab, content };\n};\n\n/**\n * Returns a parent dropdown.\n *\n * @param element the `Tab` element\n * @returns the parent dropdown\n */\nconst getParentDropdown = (element?: HTMLElement): HTMLElement | null => {\n  /* istanbul ignore next */\n  if (!isHTMLElement(element)) return null;\n  const dropdown = closest(element, `.${dropdownClasses.join(',.')}`);\n  return dropdown ? querySelector(`.${dropdownClasses[0]}-toggle`, dropdown) : null;\n};\n\n// TAB EVENT HANDLER\n// =================\n/**\n * Handles the `click` event listener.\n *\n * @param e the `Event` object\n */\nconst tabClickHandler = (e: Event) => {\n  const self = getTabInstance(e.target as HTMLElement);\n\n  /* istanbul ignore else */\n  if (self) {\n    e.preventDefault();\n    self.show();\n  }\n};\n\n// TAB DEFINITION\n// ==============\n/** Creates a new `Tab` instance. */\nexport default class Tab extends BaseComponent {\n  static selector = tabSelector;\n  static init = tabInitCallback;\n  static getInstance = getTabInstance;\n  declare nav: HTMLElement | null;\n  declare content: HTMLElement | null;\n  declare tabContent: HTMLElement | null;\n  declare nextContent: HTMLElement | null;\n  declare dropdown: HTMLElement | null;\n\n  /** @param target the target element */\n  constructor(target: HTMLElement | string) {\n    super(target);\n\n    // initialization element\n    const { element } = this;\n    const content = getTargetElement(element);\n\n    // no point initializing a tab without a corresponding content\n    /* istanbul ignore else */\n    if (content) {\n      const nav = closest(element, '.nav');\n      const container = closest(content, '.tab-content');\n\n      this.nav = nav;\n      this.content = content;\n      this.tabContent = container;\n\n      // event targets\n      this.dropdown = getParentDropdown(element);\n\n      // show first Tab instance of none is shown\n      // suggested on #432\n      const { tab } = getActiveTab(this);\n      if (nav && !tab) {\n        const firstTab = querySelector(tabSelector, nav);\n        const firstTabContent = firstTab && getTargetElement(firstTab);\n\n        /* istanbul ignore else */\n        if (firstTabContent) {\n          addClass(firstTab, activeClass);\n          addClass(firstTabContent, showClass);\n          addClass(firstTabContent, activeClass);\n          setAttribute(element, ariaSelected, 'true');\n        }\n      }\n\n      // add event listener\n      this._toggleEventListeners(true);\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return tabComponent;\n  }\n\n  // TAB PUBLIC METHODS\n  // ==================\n  /** Shows the tab to the user. */\n  show() {\n    const { element, content: nextContent, nav, dropdown } = this;\n\n    /* istanbul ignore else */\n    if (!(nav && Timer.get(nav)) && !hasClass(element, activeClass)) {\n      const { tab, content } = getActiveTab(this);\n\n      /* istanbul ignore else */\n      if (nav) tabPrivate.set(nav, { tab, content, currentHeight: 0, nextHeight: 0 });\n\n      // update relatedTarget and dispatch\n      hideTabEvent.relatedTarget = element;\n\n      /* istanbul ignore else */\n      if (isHTMLElement(tab)) {\n        dispatchEvent(tab as EventTarget, hideTabEvent);\n        /* istanbul ignore else */\n        if (!hideTabEvent.defaultPrevented) {\n          addClass(element, activeClass);\n          setAttribute(element, ariaSelected, 'true');\n\n          const activeDropdown = isHTMLElement(tab) && getParentDropdown(tab);\n          if (activeDropdown && hasClass(activeDropdown, activeClass)) {\n            removeClass(activeDropdown, activeClass);\n          }\n\n          /* istanbul ignore else */\n          if (nav) {\n            const toggleTab = () => {\n              if (tab) {\n                removeClass(tab, activeClass);\n                setAttribute(tab, ariaSelected, 'false');\n              }\n              if (dropdown && !hasClass(dropdown, activeClass)) addClass(dropdown, activeClass);\n            };\n\n            if (content && (hasClass(content, fadeClass) || (nextContent && hasClass(nextContent, fadeClass)))) {\n              Timer.set(nav, toggleTab, 1);\n            } else toggleTab();\n          }\n\n          if (content) {\n            removeClass(content, showClass);\n            if (hasClass(content, fadeClass)) {\n              emulateTransitionEnd(content, () => triggerTabHide(this));\n            } else {\n              triggerTabHide(this);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Toggles on/off the `click` event listener.\n   *\n   * @param add when `true`, event listener is added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    action(this.element, mouseclickEvent, tabClickHandler);\n  };\n\n  /** Removes the `Tab` component from the target element. */\n  dispose() {\n    this._toggleEventListeners();\n    super.dispose();\n  }\n}\n","/** @type {string} */\nconst toastString = 'toast';\nexport default toastString;\n","/** @type {string} */\nconst toastComponent = 'Toast';\nexport default toastComponent;\n","/* Native JavaScript for Bootstrap 5 | Toast\n-------------------------------------------- */\nimport {\n  mouseclickEvent,\n  closest,\n  removeClass,\n  hasClass,\n  addClass,\n  focusoutEvent,\n  focusinEvent,\n  mouseleaveEvent,\n  mouseenterEvent,\n  createCustomEvent,\n  getDocument,\n  Timer,\n  getInstance,\n  reflow,\n  emulateTransitionEnd,\n  dispatchEvent,\n  querySelectorAll,\n  querySelector,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport fadeClass from '../strings/fadeClass';\nimport showClass from '../strings/showClass';\nimport dataBsDismiss from '../strings/dataBsDismiss';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport toastString from '../strings/toastString';\nimport toastComponent from '../strings/toastComponent';\nimport getTargetElement from '../util/getTargetElement';\nimport BaseComponent from './base-component';\nimport { ToastOptions, ToastEvent } from '../interface/toast';\n\n// TOAST PRIVATE GC\n// ================\nconst toastSelector = `.${toastString}`;\nconst toastDismissSelector = `[${dataBsDismiss}=\"${toastString}\"]`;\nconst toastToggleSelector = `[${dataBsToggle}=\"${toastString}\"]`;\nconst showingClass = 'showing';\n/** @deprecated */\nconst hideClass = 'hide';\n\nconst toastDefaults = {\n  animation: true,\n  autohide: true,\n  delay: 5000,\n};\n\n/**\n * Static method which returns an existing `Toast` instance associated\n * to a target `Element`.\n */\nconst getToastInstance = (element: HTMLElement) => getInstance<Toast>(element, toastComponent);\n\n/**\n * A `Toast` initialization callback.\n */\nconst toastInitCallback = (element: HTMLElement) => new Toast(element);\n\n// TOAST CUSTOM EVENTS\n// ===================\nconst showToastEvent = createCustomEvent<ToastEvent>(`show.bs.${toastString}`);\nconst shownToastEvent = createCustomEvent<ToastEvent>(`shown.bs.${toastString}`);\nconst hideToastEvent = createCustomEvent<ToastEvent>(`hide.bs.${toastString}`);\nconst hiddenToastEvent = createCustomEvent<ToastEvent>(`hidden.bs.${toastString}`);\n\n// TOAST PRIVATE METHODS\n// =====================\n/**\n * Executes after the toast is shown to the user.\n *\n * @param self the `Toast` instance\n */\nconst showToastComplete = (self: Toast) => {\n  const { element, options } = self;\n  removeClass(element, showingClass);\n  Timer.clear(element, showingClass);\n\n  dispatchEvent(element, shownToastEvent);\n  /* istanbul ignore else */\n  if (options.autohide) {\n    Timer.set(element, () => self.hide(), options.delay, toastString);\n  }\n};\n\n/**\n * Executes after the toast is hidden to the user.\n *\n * @param self the `Toast` instance\n */\nconst hideToastComplete = (self: Toast) => {\n  const { element } = self;\n  removeClass(element, showingClass);\n  removeClass(element, showClass);\n  addClass(element, hideClass); // B/C\n  Timer.clear(element, toastString);\n  dispatchEvent(element, hiddenToastEvent);\n};\n\n/**\n * Executes before hiding the toast.\n *\n * @param self the `Toast` instance\n */\nconst hideToast = (self: Toast) => {\n  const { element, options } = self;\n  addClass(element, showingClass);\n\n  if (options.animation) {\n    reflow(element);\n    emulateTransitionEnd(element, () => hideToastComplete(self));\n  } else {\n    hideToastComplete(self);\n  }\n};\n\n/**\n * Executes before showing the toast.\n *\n * @param self the `Toast` instance\n */\nconst showToast = (self: Toast) => {\n  const { element, options } = self;\n  Timer.set(\n    element,\n    () => {\n      removeClass(element, hideClass); // B/C\n      reflow(element);\n      addClass(element, showClass);\n      addClass(element, showingClass);\n\n      if (options.animation) {\n        emulateTransitionEnd(element, () => showToastComplete(self));\n      } else {\n        showToastComplete(self);\n      }\n    },\n    17,\n    showingClass,\n  );\n};\n\n// TOAST EVENT HANDLERS\n// ====================\n/**\n * Executes after the instance has been disposed.\n *\n * @param {Toast} self the `Toast` instance\n */\nconst completeDisposeToast = (self: Toast) => {\n  Timer.clear(self.element, toastString);\n  self._toggleEventListeners();\n};\n\n/**\n * Handles the `click` event listener for toast.\n *\n * @param e the `Event` object\n */\nconst toastClickHandler = (e: Event) => {\n  const { target } = e;\n\n  const trigger = target && closest(target as HTMLElement, toastToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getToastInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    /* istanbul ignore else */\n    if (trigger && trigger.tagName === 'A') e.preventDefault();\n    self.relatedTarget = trigger;\n    self.show();\n  }\n};\n\n/**\n * Executes when user interacts with the toast without closing it,\n * usually by hovering or focusing it.\n *\n * @param e the `Toast` instance\n */\nconst interactiveToastHandler = (e: MouseEvent) => {\n  const element = e.target as HTMLElement;\n  const self = getToastInstance(element);\n  const { type, relatedTarget } = e;\n\n  /* istanbul ignore else: a solid filter is required */\n  if (self && element !== relatedTarget && !element.contains(relatedTarget as Node)) {\n    if ([mouseenterEvent, focusinEvent].includes(type)) {\n      Timer.clear(element, toastString);\n    } else {\n      Timer.set(element, () => self.hide(), self.options.delay, toastString);\n    }\n  }\n};\n\n// TOAST DEFINITION\n// ================\n/** Creates a new `Toast` instance. */\nexport default class Toast extends BaseComponent {\n  static selector = toastSelector;\n  static init = toastInitCallback;\n  static getInstance = getToastInstance;\n  declare options: ToastOptions;\n  declare dismiss: HTMLElement | null;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: HTMLElement | null;\n\n  /**\n   * @param target the target `.toast` element\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<ToastOptions>) {\n    super(target, config);\n    const { element, options } = this;\n\n    // set fadeClass, the options.animation will override the markup\n    if (options.animation && !hasClass(element, fadeClass)) addClass(element, fadeClass);\n    else if (!options.animation && hasClass(element, fadeClass)) removeClass(element, fadeClass);\n\n    // dismiss button\n    this.dismiss = querySelector(toastDismissSelector, element);\n\n    // toast can have multiple triggering elements\n    this.triggers = [...querySelectorAll(toastToggleSelector, getDocument(element))].filter(\n      btn => getTargetElement(btn) === element,\n    );\n\n    // add event listener\n    this._toggleEventListeners(true);\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return toastComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return toastDefaults;\n  }\n  /**\n   * Returns *true* when toast is visible.\n   */\n  get isShown() {\n    return hasClass(this.element, showClass);\n  }\n\n  // TOAST PUBLIC METHODS\n  // ====================\n  /** Shows the toast. */\n  show = () => {\n    const { element, isShown } = this;\n\n    /* istanbul ignore else */\n    if (element && !isShown) {\n      dispatchEvent(element, showToastEvent);\n      if (!showToastEvent.defaultPrevented) {\n        showToast(this);\n      }\n    }\n  };\n\n  /** Hides the toast. */\n  hide = () => {\n    const { element, isShown } = this;\n\n    /* istanbul ignore else */\n    if (element && isShown) {\n      dispatchEvent(element, hideToastEvent);\n      if (!hideToastEvent.defaultPrevented) {\n        hideToast(this);\n      }\n    }\n  };\n\n  /**\n   * Toggles on/off the `click` event listener.\n   *\n   * @param add when `true`, it will add the listener\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    const { element, triggers, dismiss, options, hide } = this;\n\n    /* istanbul ignore else */\n    if (dismiss) {\n      action(dismiss, mouseclickEvent, hide);\n    }\n\n    /* istanbul ignore else */\n    if (options.autohide) {\n      [focusinEvent, focusoutEvent, mouseenterEvent, mouseleaveEvent].forEach(e =>\n        action(element, e, interactiveToastHandler),\n      );\n    }\n    /* istanbul ignore else */\n    if (triggers.length) {\n      triggers.forEach(btn => action(btn, mouseclickEvent, toastClickHandler));\n    }\n  };\n\n  /** Removes the `Toast` component from the target element. */\n  dispose() {\n    const { element, isShown } = this;\n\n    /* istanbul ignore else */\n    if (isShown) {\n      removeClass(element, showClass);\n    }\n\n    completeDisposeToast(this);\n\n    super.dispose();\n  }\n}\n","import { Data, getElementsByTagName, matches } from '@thednp/shorty';\n\nimport { addListener } from '@thednp/event-listener';\n\nimport Alert from '../components/alert';\nimport Button from '../components/button';\nimport Carousel from '../components/carousel';\nimport Collapse from '../components/collapse';\nimport Dropdown from '../components/dropdown';\nimport Modal from '../components/modal';\nimport Offcanvas from '../components/offcanvas';\nimport Popover from '../components/popover';\nimport ScrollSpy from '../components/scrollspy';\nimport Tab from '../components/tab';\nimport Toast from '../components/toast';\nimport Tooltip from '../components/tooltip';\n\nconst componentsList = new Map<\n  string,\n  | typeof Alert\n  | typeof Button\n  | typeof Carousel\n  | typeof Collapse\n  | typeof Dropdown\n  | typeof Modal\n  | typeof Offcanvas\n  | typeof Popover\n  | typeof ScrollSpy\n  | typeof Tab\n  | typeof Toast\n  | typeof Tooltip\n>();\n\n[Alert, Button, Carousel, Collapse, Dropdown, Modal, Offcanvas, Popover, ScrollSpy, Tab, Toast, Tooltip].forEach(c =>\n  componentsList.set(c.prototype.name, c),\n);\n\n/**\n * Initialize all matched `Element`s for one component.\n *\n * @param callback\n * @param collection\n */\nconst initComponentDataAPI = <T>(\n  callback: (el: HTMLElement, ops?: Record<string, unknown>) => T,\n  collection: HTMLCollectionOf<HTMLElement> | HTMLElement[],\n) => {\n  [...collection].forEach(x => callback(x));\n};\n\n/**\n * Remove one component from a target container element or all in the page.\n *\n * @param component the component name\n * @param context parent `Node`\n */\nconst removeComponentDataAPI = <T>(component: string, context: ParentNode) => {\n  const compData = Data.getAllFor(component) as Map<HTMLElement, T>;\n\n  if (compData) {\n    [...compData].forEach(([element, instance]) => {\n      if (context.contains(element)) (instance as T & { dispose: () => void }).dispose();\n    });\n  }\n};\n\n/**\n * Initialize all BSN components for a target container.\n *\n * @param context parent `Node`\n */\nexport const initCallback = (context?: ParentNode) => {\n  const lookUp = context && context.nodeName ? context : document;\n  const elemCollection = [...getElementsByTagName('*', lookUp)];\n\n  componentsList.forEach(cs => {\n    const { init, selector } = cs;\n    initComponentDataAPI(\n      init,\n      elemCollection.filter(item => matches(item, selector)),\n    );\n  });\n};\n\n/**\n * Remove all BSN components for a target container.\n *\n * @param context parent `Node`\n */\nexport const removeDataAPI = (context?: ParentNode) => {\n  const lookUp = context && context.nodeName ? context : document;\n\n  componentsList.forEach(comp => {\n    removeComponentDataAPI(comp.prototype.name, lookUp);\n  });\n};\n\n// Bulk initialize all components\nif (document.body) initCallback();\nelse {\n  addListener(document, 'DOMContentLoaded', () => initCallback(), { once: true });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}