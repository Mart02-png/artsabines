{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst qs = __importStar(require(\"querystring\"));\nconst resolveScript_1 = require(\"./resolveScript\");\nconst fs = require(\"fs\");\nconst compiler_1 = require(\"./compiler\");\nconst descriptorCache_1 = require(\"./descriptorCache\");\nconst util_1 = require(\"./util\");\nconst RuleSet = require('webpack/lib/RuleSet');\nconst id = 'vue-loader-plugin';\nconst NS = 'vue-loader';\nclass VueLoaderPlugin {\n  apply(compiler) {\n    // inject NS for plugin installation check in the main loader\n    compiler.hooks.compilation.tap(id, compilation => {\n      compilation.hooks.normalModuleLoader.tap(id, loaderContext => {\n        loaderContext[NS] = true;\n      });\n    });\n    const rawRules = compiler.options.module.rules;\n    // use webpack's RuleSet utility to normalize user rules\n    const rules = new RuleSet(rawRules).rules;\n    // find the rule that applies to vue files\n    let vueRuleIndex = rawRules.findIndex(createMatcher(`foo.vue`));\n    if (vueRuleIndex < 0) {\n      vueRuleIndex = rawRules.findIndex(createMatcher(`foo.vue.html`));\n    }\n    const vueRule = rules[vueRuleIndex];\n    if (!vueRule) {\n      throw new Error(`[VueLoaderPlugin Error] No matching rule for .vue files found.\\n` + `Make sure there is at least one root-level rule that matches .vue or .vue.html files.`);\n    }\n    if (vueRule.oneOf) {\n      throw new Error(`[VueLoaderPlugin Error] vue-loader currently does not support vue rules with oneOf.`);\n    }\n    // get the normlized \"use\" for vue files\n    const vueUse = vueRule.use;\n    // get vue-loader options\n    const vueLoaderUseIndex = vueUse.findIndex(u => {\n      // FIXME: this code logic is incorrect when project paths starts with `vue-loader-something`\n      return /^vue-loader|(\\/|\\\\|@)vue-loader/.test(u.loader || '');\n    });\n    if (vueLoaderUseIndex < 0) {\n      throw new Error(`[VueLoaderPlugin Error] No matching use for vue-loader is found.\\n` + `Make sure the rule matching .vue files include vue-loader in its use.`);\n    }\n    const vueLoaderUse = vueUse[vueLoaderUseIndex];\n    const vueLoaderOptions = vueLoaderUse.options = vueLoaderUse.options || {};\n    // for each user rule (except the vue rule), create a cloned rule\n    // that targets the corresponding language blocks in *.vue files.\n    const clonedRules = rules.filter(r => r !== vueRule).map(cloneRule);\n    // rule for template compiler\n    const templateCompilerRule = {\n      loader: require.resolve('./templateLoader'),\n      resourceQuery: query => {\n        const parsed = qs.parse(query.slice(1));\n        return parsed.vue != null && parsed.type === 'template';\n      },\n      options: Object.assign({\n        ident: vueLoaderUse.ident\n      }, vueLoaderOptions)\n    };\n    // for each rule that matches plain .js/.ts files, also create a clone and\n    // match it against the compiled template code inside *.vue files, so that\n    // compiled vue render functions receive the same treatment as user code\n    // (mostly babel)\n    const matchesJS = createMatcher(`test.js`);\n    const matchesTS = createMatcher(`test.ts`);\n    const jsRulesForRenderFn = rules.filter(r => r !== vueRule && (matchesJS(r) || matchesTS(r))).map(cloneRuleForRenderFn);\n    // pitcher for block requests (for injecting stylePostLoader and deduping\n    // loaders matched for src imports)\n    const pitcher = {\n      loader: require.resolve('./pitcher'),\n      resourceQuery: query => {\n        const parsed = qs.parse(query.slice(1));\n        return parsed.vue != null;\n      }\n    };\n    // replace original rules\n    compiler.options.module.rules = [pitcher, ...jsRulesForRenderFn, templateCompilerRule, ...clonedRules, ...rules];\n    // 3.3 HMR support for imported types\n    if ((0, util_1.needHMR)(vueLoaderOptions, compiler.options) && compiler_1.compiler.invalidateTypeCache) {\n      let watcher;\n      const WatchPack = require('watchpack');\n      compiler.hooks.afterCompile.tap(id, compilation => {\n        if (compilation.compiler === compiler) {\n          // type-only imports can be tree-shaken and not registered as a\n          // watched file at all, so we have to manually ensure they are watched.\n          const files = [...resolveScript_1.typeDepToSFCMap.keys()];\n          const oldWatcher = watcher;\n          watcher = new WatchPack({\n            aggregateTimeout: 0\n          });\n          watcher.once('aggregated', (changes, removals) => {\n            for (const file of changes) {\n              // bust compiler-sfc type dep cache\n              compiler_1.compiler.invalidateTypeCache(file);\n              const affectedSFCs = resolveScript_1.typeDepToSFCMap.get(file);\n              if (affectedSFCs) {\n                for (const sfc of affectedSFCs) {\n                  // bust script resolve cache\n                  const desc = descriptorCache_1.descriptorCache.get(sfc);\n                  if (desc) resolveScript_1.clientCache.delete(desc);\n                  // force update importing SFC\n                  fs.writeFileSync(sfc, fs.readFileSync(sfc, 'utf-8'));\n                }\n              }\n            }\n            for (const file of removals) {\n              compiler_1.compiler.invalidateTypeCache(file);\n            }\n          });\n          watcher.watch({\n            files,\n            startTime: Date.now()\n          });\n          if (oldWatcher) {\n            oldWatcher.close();\n          }\n        }\n      });\n      compiler.hooks.watchClose.tap(id, () => {\n        if (watcher) {\n          watcher.close();\n        }\n      });\n      // In some cases, e.g. in this project's tests,\n      // even though needsHMR() returns true, webpack is not watching, thus no watchClose hook is called.\n      // So we need to close the watcher when webpack is done.\n      compiler.hooks.done.tap(id, () => {\n        if (watcher) {\n          watcher.close();\n        }\n      });\n    }\n  }\n}\nVueLoaderPlugin.NS = NS;\nfunction createMatcher(fakeFile) {\n  return rule => {\n    // #1201 we need to skip the `include` check when locating the vue rule\n    const clone = Object.assign({}, rule);\n    delete clone.include;\n    const normalized = RuleSet.normalizeRule(clone, {}, '');\n    return !rule.enforce && normalized.resource && normalized.resource(fakeFile);\n  };\n}\nfunction cloneRule(rule) {\n  const resource = rule.resource;\n  const resourceQuery = rule.resourceQuery;\n  // Assuming `test` and `resourceQuery` tests are executed in series and\n  // synchronously (which is true based on RuleSet's implementation), we can\n  // save the current resource being matched from `test` so that we can access\n  // it in `resourceQuery`. This ensures when we use the normalized rule's\n  // resource check, include/exclude are matched correctly.\n  let currentResource;\n  const res = Object.assign(Object.assign({}, rule), {\n    resource: resource => {\n      currentResource = resource;\n      return true;\n    },\n    resourceQuery: query => {\n      const parsed = qs.parse(query.slice(1));\n      if (parsed.vue == null) {\n        return false;\n      }\n      if (resource && parsed.lang == null) {\n        return false;\n      }\n      const fakeResourcePath = `${currentResource}.${parsed.lang}`;\n      if (resource && !resource(fakeResourcePath)) {\n        return false;\n      }\n      if (resourceQuery && !resourceQuery(query)) {\n        return false;\n      }\n      return true;\n    }\n  });\n  if (rule.rules) {\n    res.rules = rule.rules.map(cloneRule);\n  }\n  if (rule.oneOf) {\n    res.oneOf = rule.oneOf.map(cloneRule);\n  }\n  return res;\n}\nfunction cloneRuleForRenderFn(rule) {\n  const resource = rule.resource;\n  const resourceQuery = rule.resourceQuery;\n  let currentResource;\n  const res = Object.assign(Object.assign({}, rule), {\n    resource: resource => {\n      currentResource = resource;\n      return true;\n    },\n    resourceQuery: query => {\n      const parsed = qs.parse(query.slice(1));\n      if (parsed.vue == null || parsed.type !== 'template') {\n        return false;\n      }\n      const fakeResourcePath = `${currentResource}.${parsed.ts ? `ts` : `js`}`;\n      if (resource && !resource(fakeResourcePath)) {\n        return false;\n      }\n      if (resourceQuery && !resourceQuery(query)) {\n        return false;\n      }\n      return true;\n    }\n  });\n  if (rule.rules) {\n    res.rules = rule.rules.map(cloneRuleForRenderFn);\n  }\n  if (rule.oneOf) {\n    res.oneOf = rule.oneOf.map(cloneRuleForRenderFn);\n  }\n  return res;\n}\nexports.default = VueLoaderPlugin;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","exports","qs","require","resolveScript_1","fs","compiler_1","descriptorCache_1","util_1","RuleSet","id","NS","VueLoaderPlugin","apply","compiler","hooks","compilation","tap","normalModuleLoader","loaderContext","rawRules","options","module","rules","vueRuleIndex","findIndex","createMatcher","vueRule","Error","oneOf","vueUse","use","vueLoaderUseIndex","u","test","loader","vueLoaderUse","vueLoaderOptions","clonedRules","filter","r","map","cloneRule","templateCompilerRule","resolve","resourceQuery","query","parsed","parse","slice","vue","type","assign","ident","matchesJS","matchesTS","jsRulesForRenderFn","cloneRuleForRenderFn","pitcher","needHMR","invalidateTypeCache","watcher","WatchPack","afterCompile","files","typeDepToSFCMap","keys","oldWatcher","aggregateTimeout","once","changes","removals","file","affectedSFCs","sfc","desc","descriptorCache","clientCache","delete","writeFileSync","readFileSync","watch","startTime","Date","now","close","watchClose","done","fakeFile","rule","clone","include","normalized","normalizeRule","enforce","resource","currentResource","res","lang","fakeResourcePath","ts","default"],"sources":["C:/Users/Asus/Desktop/Clinic/Working System/clinicsystem/node_modules/vue-loader/dist/pluginWebpack4.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst qs = __importStar(require(\"querystring\"));\nconst resolveScript_1 = require(\"./resolveScript\");\nconst fs = require(\"fs\");\nconst compiler_1 = require(\"./compiler\");\nconst descriptorCache_1 = require(\"./descriptorCache\");\nconst util_1 = require(\"./util\");\nconst RuleSet = require('webpack/lib/RuleSet');\nconst id = 'vue-loader-plugin';\nconst NS = 'vue-loader';\nclass VueLoaderPlugin {\n    apply(compiler) {\n        // inject NS for plugin installation check in the main loader\n        compiler.hooks.compilation.tap(id, (compilation) => {\n            compilation.hooks.normalModuleLoader.tap(id, (loaderContext) => {\n                loaderContext[NS] = true;\n            });\n        });\n        const rawRules = compiler.options.module.rules;\n        // use webpack's RuleSet utility to normalize user rules\n        const rules = new RuleSet(rawRules).rules;\n        // find the rule that applies to vue files\n        let vueRuleIndex = rawRules.findIndex(createMatcher(`foo.vue`));\n        if (vueRuleIndex < 0) {\n            vueRuleIndex = rawRules.findIndex(createMatcher(`foo.vue.html`));\n        }\n        const vueRule = rules[vueRuleIndex];\n        if (!vueRule) {\n            throw new Error(`[VueLoaderPlugin Error] No matching rule for .vue files found.\\n` +\n                `Make sure there is at least one root-level rule that matches .vue or .vue.html files.`);\n        }\n        if (vueRule.oneOf) {\n            throw new Error(`[VueLoaderPlugin Error] vue-loader currently does not support vue rules with oneOf.`);\n        }\n        // get the normlized \"use\" for vue files\n        const vueUse = vueRule.use;\n        // get vue-loader options\n        const vueLoaderUseIndex = vueUse.findIndex((u) => {\n            // FIXME: this code logic is incorrect when project paths starts with `vue-loader-something`\n            return /^vue-loader|(\\/|\\\\|@)vue-loader/.test(u.loader || '');\n        });\n        if (vueLoaderUseIndex < 0) {\n            throw new Error(`[VueLoaderPlugin Error] No matching use for vue-loader is found.\\n` +\n                `Make sure the rule matching .vue files include vue-loader in its use.`);\n        }\n        const vueLoaderUse = vueUse[vueLoaderUseIndex];\n        const vueLoaderOptions = (vueLoaderUse.options =\n            vueLoaderUse.options || {});\n        // for each user rule (except the vue rule), create a cloned rule\n        // that targets the corresponding language blocks in *.vue files.\n        const clonedRules = rules.filter((r) => r !== vueRule).map(cloneRule);\n        // rule for template compiler\n        const templateCompilerRule = {\n            loader: require.resolve('./templateLoader'),\n            resourceQuery: (query) => {\n                const parsed = qs.parse(query.slice(1));\n                return parsed.vue != null && parsed.type === 'template';\n            },\n            options: Object.assign({ ident: vueLoaderUse.ident }, vueLoaderOptions),\n        };\n        // for each rule that matches plain .js/.ts files, also create a clone and\n        // match it against the compiled template code inside *.vue files, so that\n        // compiled vue render functions receive the same treatment as user code\n        // (mostly babel)\n        const matchesJS = createMatcher(`test.js`);\n        const matchesTS = createMatcher(`test.ts`);\n        const jsRulesForRenderFn = rules\n            .filter((r) => r !== vueRule && (matchesJS(r) || matchesTS(r)))\n            .map(cloneRuleForRenderFn);\n        // pitcher for block requests (for injecting stylePostLoader and deduping\n        // loaders matched for src imports)\n        const pitcher = {\n            loader: require.resolve('./pitcher'),\n            resourceQuery: (query) => {\n                const parsed = qs.parse(query.slice(1));\n                return parsed.vue != null;\n            },\n        };\n        // replace original rules\n        compiler.options.module.rules = [\n            pitcher,\n            ...jsRulesForRenderFn,\n            templateCompilerRule,\n            ...clonedRules,\n            ...rules,\n        ];\n        // 3.3 HMR support for imported types\n        if ((0, util_1.needHMR)(vueLoaderOptions, compiler.options) &&\n            compiler_1.compiler.invalidateTypeCache) {\n            let watcher;\n            const WatchPack = require('watchpack');\n            compiler.hooks.afterCompile.tap(id, (compilation) => {\n                if (compilation.compiler === compiler) {\n                    // type-only imports can be tree-shaken and not registered as a\n                    // watched file at all, so we have to manually ensure they are watched.\n                    const files = [...resolveScript_1.typeDepToSFCMap.keys()];\n                    const oldWatcher = watcher;\n                    watcher = new WatchPack({ aggregateTimeout: 0 });\n                    watcher.once('aggregated', (changes, removals) => {\n                        for (const file of changes) {\n                            // bust compiler-sfc type dep cache\n                            compiler_1.compiler.invalidateTypeCache(file);\n                            const affectedSFCs = resolveScript_1.typeDepToSFCMap.get(file);\n                            if (affectedSFCs) {\n                                for (const sfc of affectedSFCs) {\n                                    // bust script resolve cache\n                                    const desc = descriptorCache_1.descriptorCache.get(sfc);\n                                    if (desc)\n                                        resolveScript_1.clientCache.delete(desc);\n                                    // force update importing SFC\n                                    fs.writeFileSync(sfc, fs.readFileSync(sfc, 'utf-8'));\n                                }\n                            }\n                        }\n                        for (const file of removals) {\n                            compiler_1.compiler.invalidateTypeCache(file);\n                        }\n                    });\n                    watcher.watch({ files, startTime: Date.now() });\n                    if (oldWatcher) {\n                        oldWatcher.close();\n                    }\n                }\n            });\n            compiler.hooks.watchClose.tap(id, () => {\n                if (watcher) {\n                    watcher.close();\n                }\n            });\n            // In some cases, e.g. in this project's tests,\n            // even though needsHMR() returns true, webpack is not watching, thus no watchClose hook is called.\n            // So we need to close the watcher when webpack is done.\n            compiler.hooks.done.tap(id, () => {\n                if (watcher) {\n                    watcher.close();\n                }\n            });\n        }\n    }\n}\nVueLoaderPlugin.NS = NS;\nfunction createMatcher(fakeFile) {\n    return (rule) => {\n        // #1201 we need to skip the `include` check when locating the vue rule\n        const clone = Object.assign({}, rule);\n        delete clone.include;\n        const normalized = RuleSet.normalizeRule(clone, {}, '');\n        return !rule.enforce && normalized.resource && normalized.resource(fakeFile);\n    };\n}\nfunction cloneRule(rule) {\n    const resource = rule.resource;\n    const resourceQuery = rule.resourceQuery;\n    // Assuming `test` and `resourceQuery` tests are executed in series and\n    // synchronously (which is true based on RuleSet's implementation), we can\n    // save the current resource being matched from `test` so that we can access\n    // it in `resourceQuery`. This ensures when we use the normalized rule's\n    // resource check, include/exclude are matched correctly.\n    let currentResource;\n    const res = Object.assign(Object.assign({}, rule), { resource: (resource) => {\n            currentResource = resource;\n            return true;\n        }, resourceQuery: (query) => {\n            const parsed = qs.parse(query.slice(1));\n            if (parsed.vue == null) {\n                return false;\n            }\n            if (resource && parsed.lang == null) {\n                return false;\n            }\n            const fakeResourcePath = `${currentResource}.${parsed.lang}`;\n            if (resource && !resource(fakeResourcePath)) {\n                return false;\n            }\n            if (resourceQuery && !resourceQuery(query)) {\n                return false;\n            }\n            return true;\n        } });\n    if (rule.rules) {\n        res.rules = rule.rules.map(cloneRule);\n    }\n    if (rule.oneOf) {\n        res.oneOf = rule.oneOf.map(cloneRule);\n    }\n    return res;\n}\nfunction cloneRuleForRenderFn(rule) {\n    const resource = rule.resource;\n    const resourceQuery = rule.resourceQuery;\n    let currentResource;\n    const res = Object.assign(Object.assign({}, rule), { resource: (resource) => {\n            currentResource = resource;\n            return true;\n        }, resourceQuery: (query) => {\n            const parsed = qs.parse(query.slice(1));\n            if (parsed.vue == null || parsed.type !== 'template') {\n                return false;\n            }\n            const fakeResourcePath = `${currentResource}.${parsed.ts ? `ts` : `js`}`;\n            if (resource && !resource(fakeResourcePath)) {\n                return false;\n            }\n            if (resourceQuery && !resourceQuery(query)) {\n                return false;\n            }\n            return true;\n        } });\n    if (rule.rules) {\n        res.rules = rule.rules.map(cloneRuleForRenderFn);\n    }\n    if (rule.oneOf) {\n        res.oneOf = rule.oneOf.map(cloneRuleForRenderFn);\n    }\n    return res;\n}\nexports.default = VueLoaderPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}